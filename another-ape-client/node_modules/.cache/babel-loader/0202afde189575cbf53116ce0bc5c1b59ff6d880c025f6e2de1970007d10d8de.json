{"ast":null,"code":"var AWS = require('../core');\nvar util = AWS.util;\nvar Shape = AWS.Model.Shape;\nvar xml2js = require('xml2js');\n\n/**\n * @api private\n */\nvar options = {\n  // options passed to xml2js parser\n  explicitCharkey: false,\n  // undocumented\n  trim: false,\n  // trim the leading/trailing whitespace from text nodes\n  normalize: false,\n  // trim interior whitespace inside text nodes\n  explicitRoot: false,\n  // return the root node in the resulting object?\n  emptyTag: null,\n  // the default value for empty nodes\n  explicitArray: true,\n  // always put child nodes in an array\n  ignoreAttrs: false,\n  // ignore attributes, only create text nodes\n  mergeAttrs: false,\n  // merge attributes and child elements\n  validator: null // a callable validator\n};\n\nfunction NodeXmlParser() {}\nNodeXmlParser.prototype.parse = function (xml, shape) {\n  shape = shape || {};\n  var result = null;\n  var error = null;\n  var parser = new xml2js.Parser(options);\n  parser.parseString(xml, function (e, r) {\n    error = e;\n    result = r;\n  });\n  if (result) {\n    var data = parseXml(result, shape);\n    if (result.ResponseMetadata) {\n      data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error, {\n      code: 'XMLParserError',\n      retryable: true\n    });\n  } else {\n    // empty xml document\n    return parseXml({}, shape);\n  }\n};\nfunction parseXml(xml, shape) {\n  switch (shape.type) {\n    case 'structure':\n      return parseStructure(xml, shape);\n    case 'map':\n      return parseMap(xml, shape);\n    case 'list':\n      return parseList(xml, shape);\n    case undefined:\n    case null:\n      return parseUnknown(xml);\n    default:\n      return parseScalar(xml, shape);\n  }\n}\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n  util.each(shape.members, function (memberName, memberShape) {\n    var xmlName = memberShape.name;\n    if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {\n      var xmlChild = xml[xmlName];\n      if (!memberShape.flattened) xmlChild = xmlChild[0];\n      data[memberName] = parseXml(xmlChild, memberShape);\n    } else if (memberShape.isXmlAttribute && xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {\n      data[memberName] = parseScalar(xml.$[xmlName], memberShape);\n    } else if (memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {\n      data[memberName] = memberShape.defaultValue;\n    }\n  });\n  return data;\n}\nfunction parseMap(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var iterable = shape.flattened ? xml : xml.entry;\n  if (Array.isArray(iterable)) {\n    util.arrayEach(iterable, function (child) {\n      data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);\n    });\n  }\n  return data;\n}\nfunction parseList(xml, shape) {\n  var data = [];\n  var name = shape.member.name || 'member';\n  if (shape.flattened) {\n    util.arrayEach(xml, function (xmlChild) {\n      data.push(parseXml(xmlChild, shape.member));\n    });\n  } else if (xml && Array.isArray(xml[name])) {\n    util.arrayEach(xml[name], function (child) {\n      data.push(parseXml(child, shape.member));\n    });\n  }\n  return data;\n}\nfunction parseScalar(text, shape) {\n  if (text && text.$ && text.$.encoding === 'base64') {\n    shape = new Shape.create({\n      type: text.$.encoding\n    });\n  }\n  if (text && text._) text = text._;\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n  if (typeof xml === 'string') return xml;\n\n  // parse a list\n  if (Array.isArray(xml)) {\n    var arr = [];\n    for (i = 0; i < xml.length; i++) {\n      arr.push(parseXml(xml[i], {}));\n    }\n    return arr;\n  }\n\n  // empty object\n  var keys = Object.keys(xml),\n    i;\n  if (keys.length === 0 || keys.length === 1 && keys[0] === '$') {\n    return {};\n  }\n\n  // object, parse as structure\n  var data = {};\n  for (i = 0; i < keys.length; i++) {\n    var key = keys[i],\n      value = xml[key];\n    if (key === '$') continue;\n    if (value.length > 1) {\n      // this member is a list\n      data[key] = parseList(value, {\n        member: {}\n      });\n    } else {\n      // this member is a single item\n      data[key] = parseXml(value[0], {});\n    }\n  }\n  return data;\n}\n\n/**\n * @api private\n */\nmodule.exports = NodeXmlParser;","map":{"version":3,"names":["AWS","require","util","Shape","Model","xml2js","options","explicitCharkey","trim","normalize","explicitRoot","emptyTag","explicitArray","ignoreAttrs","mergeAttrs","validator","NodeXmlParser","prototype","parse","xml","shape","result","error","parser","Parser","parseString","e","r","data","parseXml","ResponseMetadata","code","retryable","type","parseStructure","parseMap","parseList","undefined","parseUnknown","parseScalar","each","members","memberName","memberShape","xmlName","name","Object","hasOwnProperty","call","Array","isArray","xmlChild","flattened","isXmlAttribute","$","api","xmlNoDefaultLists","defaultValue","xmlKey","key","xmlValue","value","iterable","entry","arrayEach","child","member","push","text","encoding","create","_","toType","arr","i","length","keys","module","exports"],"sources":["/home/ryanosull/clarity/clarity-camp/projects/nft-vids/another-ape-client/node_modules/aws-sdk/lib/xml/node_parser.js"],"sourcesContent":["var AWS = require('../core');\nvar util = AWS.util;\nvar Shape = AWS.Model.Shape;\n\nvar xml2js = require('xml2js');\n\n/**\n * @api private\n */\nvar options = {  // options passed to xml2js parser\n  explicitCharkey: false, // undocumented\n  trim: false,            // trim the leading/trailing whitespace from text nodes\n  normalize: false,       // trim interior whitespace inside text nodes\n  explicitRoot: false,    // return the root node in the resulting object?\n  emptyTag: null,         // the default value for empty nodes\n  explicitArray: true,    // always put child nodes in an array\n  ignoreAttrs: false,     // ignore attributes, only create text nodes\n  mergeAttrs: false,      // merge attributes and child elements\n  validator: null         // a callable validator\n};\n\nfunction NodeXmlParser() { }\n\nNodeXmlParser.prototype.parse = function(xml, shape) {\n  shape = shape || {};\n\n  var result = null;\n  var error = null;\n\n  var parser = new xml2js.Parser(options);\n  parser.parseString(xml, function (e, r) {\n    error = e;\n    result = r;\n  });\n\n  if (result) {\n    var data = parseXml(result, shape);\n    if (result.ResponseMetadata) {\n      data.ResponseMetadata = parseXml(result.ResponseMetadata[0], {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error, {code: 'XMLParserError', retryable: true});\n  } else { // empty xml document\n    return parseXml({}, shape);\n  }\n};\n\nfunction parseXml(xml, shape) {\n  switch (shape.type) {\n    case 'structure': return parseStructure(xml, shape);\n    case 'map': return parseMap(xml, shape);\n    case 'list': return parseList(xml, shape);\n    case undefined: case null: return parseUnknown(xml);\n    default: return parseScalar(xml, shape);\n  }\n}\n\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n\n  util.each(shape.members, function(memberName, memberShape) {\n    var xmlName = memberShape.name;\n    if (Object.prototype.hasOwnProperty.call(xml, xmlName) && Array.isArray(xml[xmlName])) {\n      var xmlChild = xml[xmlName];\n      if (!memberShape.flattened) xmlChild = xmlChild[0];\n\n      data[memberName] = parseXml(xmlChild, memberShape);\n    } else if (memberShape.isXmlAttribute &&\n               xml.$ && Object.prototype.hasOwnProperty.call(xml.$, xmlName)) {\n      data[memberName] = parseScalar(xml.$[xmlName], memberShape);\n    } else if (memberShape.type === 'list' && !shape.api.xmlNoDefaultLists) {\n      data[memberName] = memberShape.defaultValue;\n    }\n  });\n\n  return data;\n}\n\nfunction parseMap(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n\n  var xmlKey = shape.key.name || 'key';\n  var xmlValue = shape.value.name || 'value';\n  var iterable = shape.flattened ? xml : xml.entry;\n\n  if (Array.isArray(iterable)) {\n    util.arrayEach(iterable, function(child) {\n      data[child[xmlKey][0]] = parseXml(child[xmlValue][0], shape.value);\n    });\n  }\n\n  return data;\n}\n\nfunction parseList(xml, shape) {\n  var data = [];\n  var name = shape.member.name || 'member';\n  if (shape.flattened) {\n    util.arrayEach(xml, function(xmlChild) {\n      data.push(parseXml(xmlChild, shape.member));\n    });\n  } else if (xml && Array.isArray(xml[name])) {\n    util.arrayEach(xml[name], function(child) {\n      data.push(parseXml(child, shape.member));\n    });\n  }\n\n  return data;\n}\n\nfunction parseScalar(text, shape) {\n  if (text && text.$ && text.$.encoding === 'base64') {\n    shape = new Shape.create({type: text.$.encoding});\n  }\n  if (text && text._) text = text._;\n\n  if (typeof shape.toType === 'function') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\n\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return '';\n  if (typeof xml === 'string') return xml;\n\n  // parse a list\n  if (Array.isArray(xml)) {\n    var arr = [];\n    for (i = 0; i < xml.length; i++) {\n      arr.push(parseXml(xml[i], {}));\n    }\n    return arr;\n  }\n\n  // empty object\n  var keys = Object.keys(xml), i;\n  if (keys.length === 0 || (keys.length === 1 && keys[0] === '$')) {\n    return {};\n  }\n\n  // object, parse as structure\n  var data = {};\n  for (i = 0; i < keys.length; i++) {\n    var key = keys[i], value = xml[key];\n    if (key === '$') continue;\n    if (value.length > 1) { // this member is a list\n      data[key] = parseList(value, {member: {}});\n    } else { // this member is a single item\n      data[key] = parseXml(value[0], {});\n    }\n  }\n  return data;\n}\n\n/**\n * @api private\n */\nmodule.exports = NodeXmlParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}