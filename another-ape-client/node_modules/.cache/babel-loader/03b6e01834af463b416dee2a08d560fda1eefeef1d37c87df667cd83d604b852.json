{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TokenSigner = exports.createUnsecuredToken = void 0;\nconst base64url = require(\"./base64Url\");\nconst cryptoClients_1 = require(\"./cryptoClients\");\nconst errors_1 = require(\"./errors\");\nconst sha256_1 = require(\"./cryptoClients/sha256\");\nfunction createSigningInput(payload, header) {\n  const tokenParts = [];\n  // add in the header\n  const encodedHeader = base64url.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader);\n  // add in the payload\n  const encodedPayload = base64url.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload);\n  // prepare the message\n  const signingInput = tokenParts.join('.');\n  // return the signing input\n  return signingInput;\n}\nfunction createUnsecuredToken(payload) {\n  const header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\nexports.createUnsecuredToken = createUnsecuredToken;\nclass TokenSigner {\n  constructor(signingAlgorithm, rawPrivateKey) {\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n  header(header = {}) {\n    const defaultHeader = {\n      typ: this.tokenType,\n      alg: this.cryptoClient.algorithmName\n    };\n    return Object.assign({}, defaultHeader, header);\n  }\n  sign(payload, expanded = false, customHeader = {}) {\n    // generate the token header\n    const header = this.header(customHeader);\n    // prepare the message to be signed\n    const signingInput = createSigningInput(payload, header);\n    const signingInputHash = (0, sha256_1.hashSha256)(signingInput);\n    return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n  }\n  signAsync(payload, expanded = false, customHeader = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // generate the token header\n      const header = this.header(customHeader);\n      // prepare the message to be signed\n      const signingInput = createSigningInput(payload, header);\n      const signingInputHash = yield (0, sha256_1.hashSha256Async)(signingInput);\n      return this.createWithSignedHash(payload, expanded, header, signingInput, signingInputHash);\n    });\n  }\n  createWithSignedHash(payload, expanded, header, signingInput, signingInputHash) {\n    // sign the message and add in the signature\n    const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n    if (expanded) {\n      const signedToken = {\n        header: [base64url.encode(JSON.stringify(header))],\n        payload: JSON.stringify(payload),\n        signature: [signature]\n      };\n      return signedToken;\n    } else {\n      return [signingInput, signature].join('.');\n    }\n  }\n}\nexports.TokenSigner = TokenSigner;","map":{"version":3,"names":["base64url","require","cryptoClients_1","errors_1","sha256_1","createSigningInput","payload","header","tokenParts","encodedHeader","encode","JSON","stringify","push","encodedPayload","signingInput","join","createUnsecuredToken","typ","alg","exports","TokenSigner","constructor","signingAlgorithm","rawPrivateKey","MissingParametersError","Error","toUpperCase","cryptoClients","hasOwnProperty","tokenType","cryptoClient","defaultHeader","algorithmName","Object","assign","sign","expanded","customHeader","signingInputHash","hashSha256","createWithSignedHash","signAsync","hashSha256Async","signature","signHash","signedToken"],"sources":["signer.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}