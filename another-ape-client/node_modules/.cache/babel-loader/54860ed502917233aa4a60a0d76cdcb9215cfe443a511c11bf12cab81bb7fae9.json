{"ast":null,"code":"var AWS = require('./core');\n\n/**\n * Represents AWS token object, which contains {token}, and optional\n * {expireTime}.\n * Creating a `Token` object allows you to pass around your\n * token to configuration and service objects.\n *\n * Note that this class typically does not need to be constructed manually,\n * as the {AWS.Config} and {AWS.Service} classes both accept simple\n * options hashes with the two keys. The token from this object will be used\n * automatically in operations which require them.\n *\n * ## Expiring and Refreshing Token\n *\n * Occasionally token can expire in the middle of a long-running\n * application. In this case, the SDK will automatically attempt to\n * refresh the token from the storage location if the Token\n * class implements the {refresh} method.\n *\n * If you are implementing a token storage location, you\n * will want to create a subclass of the `Token` class and\n * override the {refresh} method. This method allows token to be\n * retrieved from the backing store, be it a file system, database, or\n * some network storage. The method should reset the token attributes\n * on the object.\n *\n * @!attribute token\n *   @return [String] represents the literal token string. This will typically\n *     be a base64 encoded string.\n * @!attribute expireTime\n *   @return [Date] a time when token should be considered expired. Used\n *     in conjunction with {expired}.\n * @!attribute expired\n *   @return [Boolean] whether the token is expired and require a refresh. Used\n *     in conjunction with {expireTime}.\n */\nAWS.Token = AWS.util.inherit({\n  /**\n   * Creates a Token object with a given set of information in options hash.\n   * @option options token [String] represents the literal token string.\n   * @option options expireTime [Date] field representing the time at which\n   *   the token expires.\n   * @example Create a token object\n   *   var token = new AWS.Token({ token: 'token' });\n   */\n  constructor: function Token(options) {\n    // hide token from being displayed with util.inspect\n    AWS.util.hideProperties(this, ['token']);\n    this.expired = false;\n    this.expireTime = null;\n    this.refreshCallbacks = [];\n    if (arguments.length === 1) {\n      var options = arguments[0];\n      this.token = options.token;\n      this.expireTime = options.expireTime;\n    }\n  },\n  /**\n   * @return [Integer] the number of seconds before {expireTime} during which\n   *   the token will be considered expired.\n   */\n  expiryWindow: 15,\n  /**\n   * @return [Boolean] whether the Token object should call {refresh}\n   * @note Subclasses should override this method to provide custom refresh\n   *   logic.\n   */\n  needsRefresh: function needsRefresh() {\n    var currentTime = AWS.util.date.getDate().getTime();\n    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);\n    if (this.expireTime && adjustedTime > this.expireTime) return true;\n    return this.expired || !this.token;\n  },\n  /**\n   * Gets the existing token, refreshing them if they are not yet loaded\n   * or have expired. Users should call this method before using {refresh},\n   * as this will not attempt to reload token when they are already\n   * loaded into the object.\n   *\n   * @callback callback function(err)\n   *   When this callback is called with no error, it means either token\n   *   do not need to be refreshed or refreshed token information has\n   *   been loaded into the object (as the `token` property).\n   *   @param err [Error] if an error occurred, this value will be filled\n   */\n  get: function get(callback) {\n    var self = this;\n    if (this.needsRefresh()) {\n      this.refresh(function (err) {\n        if (!err) self.expired = false; // reset expired flag\n        if (callback) callback(err);\n      });\n    } else if (callback) {\n      callback();\n    }\n  },\n  /**\n   * @!method  getPromise()\n   *   Returns a 'thenable' promise.\n   *   Gets the existing token, refreshing it if it's not yet loaded\n   *   or have expired. Users should call this method before using {refresh},\n   *   as this will not attempt to reload token when it's already\n   *   loaded into the object.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function()\n   *     Called if the promise is fulfilled. When this callback is called, it means\n   *     either token does not need to be refreshed or refreshed token information\n   *     has been loaded into the object (as the `token` property).\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] if an error occurred, this value will be filled.\n   *   @return [Promise] A promise that represents the state of the `get` call.\n   *   @example Calling the `getPromise` method.\n   *     var promise = tokenProvider.getPromise();\n   *     promise.then(function() { ... }, function(err) { ... });\n   */\n\n  /**\n   * @!method  refreshPromise()\n   *   Returns a 'thenable' promise.\n   *   Refreshes the token. Users should call {get} before attempting\n   *   to forcibly refresh token.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function()\n   *     Called if the promise is fulfilled. When this callback is called, it\n   *     means refreshed token information has been loaded into the object\n   *     (as the `token` property).\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] if an error occurred, this value will be filled.\n   *   @return [Promise] A promise that represents the state of the `refresh` call.\n   *   @example Calling the `refreshPromise` method.\n   *     var promise = tokenProvider.refreshPromise();\n   *     promise.then(function() { ... }, function(err) { ... });\n   */\n\n  /**\n   * Refreshes the token. Users should call {get} before attempting\n   * to forcibly refresh token.\n   *\n   * @callback callback function(err)\n   *   When this callback is called with no error, it means refreshed\n   *   token information has been loaded into the object (as the\n   *   `token` property).\n   *   @param err [Error] if an error occurred, this value will be filled\n   * @note Subclasses should override this class to reset the\n   *   {token} on the token object and then call the callback with\n   *   any error information.\n   * @see get\n   */\n  refresh: function refresh(callback) {\n    this.expired = false;\n    callback();\n  },\n  /**\n   * @api private\n   * @param callback\n   */\n  coalesceRefresh: function coalesceRefresh(callback, sync) {\n    var self = this;\n    if (self.refreshCallbacks.push(callback) === 1) {\n      self.load(function onLoad(err) {\n        AWS.util.arrayEach(self.refreshCallbacks, function (callback) {\n          if (sync) {\n            callback(err);\n          } else {\n            // callback could throw, so defer to ensure all callbacks are notified\n            AWS.util.defer(function () {\n              callback(err);\n            });\n          }\n        });\n        self.refreshCallbacks.length = 0;\n      });\n    }\n  },\n  /**\n   * @api private\n   * @param callback\n   */\n  load: function load(callback) {\n    callback();\n  }\n});\n\n/**\n * @api private\n */\nAWS.Token.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);\n  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.Token.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.getPromise;\n  delete this.prototype.refreshPromise;\n};\nAWS.util.addPromises(AWS.Token);","map":{"version":3,"names":["AWS","require","Token","util","inherit","constructor","options","hideProperties","expired","expireTime","refreshCallbacks","arguments","length","token","expiryWindow","needsRefresh","currentTime","date","getDate","getTime","adjustedTime","Date","get","callback","self","refresh","err","coalesceRefresh","sync","push","load","onLoad","arrayEach","defer","addPromisesToClass","PromiseDependency","prototype","getPromise","promisifyMethod","refreshPromise","deletePromisesFromClass","addPromises"],"sources":["/home/ryanosull/clarity/clarity-camp/projects/nft-vids/another-ape-client/node_modules/aws-sdk/lib/token.js"],"sourcesContent":["var AWS = require('./core');\n\n/**\n * Represents AWS token object, which contains {token}, and optional\n * {expireTime}.\n * Creating a `Token` object allows you to pass around your\n * token to configuration and service objects.\n *\n * Note that this class typically does not need to be constructed manually,\n * as the {AWS.Config} and {AWS.Service} classes both accept simple\n * options hashes with the two keys. The token from this object will be used\n * automatically in operations which require them.\n *\n * ## Expiring and Refreshing Token\n *\n * Occasionally token can expire in the middle of a long-running\n * application. In this case, the SDK will automatically attempt to\n * refresh the token from the storage location if the Token\n * class implements the {refresh} method.\n *\n * If you are implementing a token storage location, you\n * will want to create a subclass of the `Token` class and\n * override the {refresh} method. This method allows token to be\n * retrieved from the backing store, be it a file system, database, or\n * some network storage. The method should reset the token attributes\n * on the object.\n *\n * @!attribute token\n *   @return [String] represents the literal token string. This will typically\n *     be a base64 encoded string.\n * @!attribute expireTime\n *   @return [Date] a time when token should be considered expired. Used\n *     in conjunction with {expired}.\n * @!attribute expired\n *   @return [Boolean] whether the token is expired and require a refresh. Used\n *     in conjunction with {expireTime}.\n */\nAWS.Token = AWS.util.inherit({\n  /**\n   * Creates a Token object with a given set of information in options hash.\n   * @option options token [String] represents the literal token string.\n   * @option options expireTime [Date] field representing the time at which\n   *   the token expires.\n   * @example Create a token object\n   *   var token = new AWS.Token({ token: 'token' });\n   */\n  constructor: function Token(options) {\n    // hide token from being displayed with util.inspect\n    AWS.util.hideProperties(this, ['token']);\n\n    this.expired = false;\n    this.expireTime = null;\n    this.refreshCallbacks = [];\n    if (arguments.length === 1) {\n      var options = arguments[0];\n      this.token = options.token;\n      this.expireTime = options.expireTime;\n    }\n  },\n\n  /**\n   * @return [Integer] the number of seconds before {expireTime} during which\n   *   the token will be considered expired.\n   */\n  expiryWindow: 15,\n\n  /**\n   * @return [Boolean] whether the Token object should call {refresh}\n   * @note Subclasses should override this method to provide custom refresh\n   *   logic.\n   */\n  needsRefresh: function needsRefresh() {\n    var currentTime = AWS.util.date.getDate().getTime();\n    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);\n\n    if (this.expireTime && adjustedTime > this.expireTime)\n      return true;\n\n    return this.expired || !this.token;\n  },\n\n  /**\n   * Gets the existing token, refreshing them if they are not yet loaded\n   * or have expired. Users should call this method before using {refresh},\n   * as this will not attempt to reload token when they are already\n   * loaded into the object.\n   *\n   * @callback callback function(err)\n   *   When this callback is called with no error, it means either token\n   *   do not need to be refreshed or refreshed token information has\n   *   been loaded into the object (as the `token` property).\n   *   @param err [Error] if an error occurred, this value will be filled\n   */\n  get: function get(callback) {\n    var self = this;\n    if (this.needsRefresh()) {\n      this.refresh(function(err) {\n        if (!err) self.expired = false; // reset expired flag\n        if (callback) callback(err);\n      });\n    } else if (callback) {\n      callback();\n    }\n  },\n\n  /**\n   * @!method  getPromise()\n   *   Returns a 'thenable' promise.\n   *   Gets the existing token, refreshing it if it's not yet loaded\n   *   or have expired. Users should call this method before using {refresh},\n   *   as this will not attempt to reload token when it's already\n   *   loaded into the object.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function()\n   *     Called if the promise is fulfilled. When this callback is called, it means\n   *     either token does not need to be refreshed or refreshed token information\n   *     has been loaded into the object (as the `token` property).\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] if an error occurred, this value will be filled.\n   *   @return [Promise] A promise that represents the state of the `get` call.\n   *   @example Calling the `getPromise` method.\n   *     var promise = tokenProvider.getPromise();\n   *     promise.then(function() { ... }, function(err) { ... });\n   */\n\n  /**\n   * @!method  refreshPromise()\n   *   Returns a 'thenable' promise.\n   *   Refreshes the token. Users should call {get} before attempting\n   *   to forcibly refresh token.\n   *\n   *   Two callbacks can be provided to the `then` method on the returned promise.\n   *   The first callback will be called if the promise is fulfilled, and the second\n   *   callback will be called if the promise is rejected.\n   *   @callback fulfilledCallback function()\n   *     Called if the promise is fulfilled. When this callback is called, it\n   *     means refreshed token information has been loaded into the object\n   *     (as the `token` property).\n   *   @callback rejectedCallback function(err)\n   *     Called if the promise is rejected.\n   *     @param err [Error] if an error occurred, this value will be filled.\n   *   @return [Promise] A promise that represents the state of the `refresh` call.\n   *   @example Calling the `refreshPromise` method.\n   *     var promise = tokenProvider.refreshPromise();\n   *     promise.then(function() { ... }, function(err) { ... });\n   */\n\n  /**\n   * Refreshes the token. Users should call {get} before attempting\n   * to forcibly refresh token.\n   *\n   * @callback callback function(err)\n   *   When this callback is called with no error, it means refreshed\n   *   token information has been loaded into the object (as the\n   *   `token` property).\n   *   @param err [Error] if an error occurred, this value will be filled\n   * @note Subclasses should override this class to reset the\n   *   {token} on the token object and then call the callback with\n   *   any error information.\n   * @see get\n   */\n  refresh: function refresh(callback) {\n    this.expired = false;\n    callback();\n  },\n\n  /**\n   * @api private\n   * @param callback\n   */\n  coalesceRefresh: function coalesceRefresh(callback, sync) {\n    var self = this;\n    if (self.refreshCallbacks.push(callback) === 1) {\n      self.load(function onLoad(err) {\n        AWS.util.arrayEach(self.refreshCallbacks, function(callback) {\n          if (sync) {\n            callback(err);\n          } else {\n            // callback could throw, so defer to ensure all callbacks are notified\n            AWS.util.defer(function () {\n              callback(err);\n            });\n          }\n        });\n        self.refreshCallbacks.length = 0;\n      });\n    }\n  },\n\n  /**\n   * @api private\n   * @param callback\n   */\n  load: function load(callback) {\n    callback();\n  }\n});\n\n/**\n * @api private\n */\nAWS.Token.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);\n  this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);\n};\n\n/**\n * @api private\n */\nAWS.Token.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.getPromise;\n  delete this.prototype.refreshPromise;\n};\n\nAWS.util.addPromises(AWS.Token);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}