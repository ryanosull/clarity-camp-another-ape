{"ast":null,"code":"var AWS = require('../core');\nvar Stream = AWS.util.stream.Stream;\nvar TransformStream = AWS.util.stream.Transform;\nvar ReadableStream = AWS.util.stream.Readable;\nrequire('../http');\nvar CONNECTION_REUSE_ENV_NAME = 'AWS_NODEJS_CONNECTION_REUSE_ENABLED';\n\n/**\n * @api private\n */\nAWS.NodeHttpClient = AWS.util.inherit({\n  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {\n    var self = this;\n    var endpoint = httpRequest.endpoint;\n    var pathPrefix = '';\n    if (!httpOptions) httpOptions = {};\n    if (httpOptions.proxy) {\n      pathPrefix = endpoint.protocol + '//' + endpoint.hostname;\n      if (endpoint.port !== 80 && endpoint.port !== 443) {\n        pathPrefix += ':' + endpoint.port;\n      }\n      endpoint = new AWS.Endpoint(httpOptions.proxy);\n    }\n    var useSSL = endpoint.protocol === 'https:';\n    var http = useSSL ? require('https') : require('http');\n    var options = {\n      host: endpoint.hostname,\n      port: endpoint.port,\n      method: httpRequest.method,\n      headers: httpRequest.headers,\n      path: pathPrefix + httpRequest.path\n    };\n    AWS.util.update(options, httpOptions);\n    if (!httpOptions.agent) {\n      options.agent = this.getAgent(useSSL, {\n        keepAlive: process.env[CONNECTION_REUSE_ENV_NAME] === '1' ? true : false\n      });\n    }\n    delete options.proxy; // proxy isn't an HTTP option\n    delete options.timeout; // timeout isn't an HTTP option\n\n    var stream = http.request(options, function (httpResp) {\n      if (stream.didCallback) return;\n      callback(httpResp);\n      httpResp.emit('headers', httpResp.statusCode, httpResp.headers, httpResp.statusMessage);\n    });\n    httpRequest.stream = stream; // attach stream to httpRequest\n    stream.didCallback = false;\n\n    // connection timeout support\n    if (httpOptions.connectTimeout) {\n      var connectTimeoutId;\n      stream.on('socket', function (socket) {\n        if (socket.connecting) {\n          connectTimeoutId = setTimeout(function connectTimeout() {\n            if (stream.didCallback) return;\n            stream.didCallback = true;\n            stream.abort();\n            errCallback(AWS.util.error(new Error('Socket timed out without establishing a connection'), {\n              code: 'TimeoutError'\n            }));\n          }, httpOptions.connectTimeout);\n          socket.on('connect', function () {\n            clearTimeout(connectTimeoutId);\n            connectTimeoutId = null;\n          });\n        }\n      });\n    }\n\n    // timeout support\n    stream.setTimeout(httpOptions.timeout || 0, function () {\n      if (stream.didCallback) return;\n      stream.didCallback = true;\n      var msg = 'Connection timed out after ' + httpOptions.timeout + 'ms';\n      errCallback(AWS.util.error(new Error(msg), {\n        code: 'TimeoutError'\n      }));\n      stream.abort();\n    });\n    stream.on('error', function (err) {\n      if (connectTimeoutId) {\n        clearTimeout(connectTimeoutId);\n        connectTimeoutId = null;\n      }\n      if (stream.didCallback) return;\n      stream.didCallback = true;\n      if ('ECONNRESET' === err.code || 'EPIPE' === err.code || 'ETIMEDOUT' === err.code) {\n        errCallback(AWS.util.error(err, {\n          code: 'TimeoutError'\n        }));\n      } else {\n        errCallback(err);\n      }\n    });\n    var expect = httpRequest.headers.Expect || httpRequest.headers.expect;\n    if (expect === '100-continue') {\n      stream.once('continue', function () {\n        self.writeBody(stream, httpRequest);\n      });\n    } else {\n      this.writeBody(stream, httpRequest);\n    }\n    return stream;\n  },\n  writeBody: function writeBody(stream, httpRequest) {\n    var body = httpRequest.body;\n    var totalBytes = parseInt(httpRequest.headers['Content-Length'], 10);\n    if (body instanceof Stream) {\n      // For progress support of streaming content -\n      // pipe the data through a transform stream to emit 'sendProgress' events\n      var progressStream = this.progressStream(stream, totalBytes);\n      if (progressStream) {\n        body.pipe(progressStream).pipe(stream);\n      } else {\n        body.pipe(stream);\n      }\n    } else if (body) {\n      // The provided body is a buffer/string and is already fully available in memory -\n      // For performance it's best to send it as a whole by calling stream.end(body),\n      // Callers expect a 'sendProgress' event which is best emitted once\n      // the http request stream has been fully written and all data flushed.\n      // The use of totalBytes is important over body.length for strings where\n      // length is char length and not byte length.\n      stream.once('finish', function () {\n        stream.emit('sendProgress', {\n          loaded: totalBytes,\n          total: totalBytes\n        });\n      });\n      stream.end(body);\n    } else {\n      // no request body\n      stream.end();\n    }\n  },\n  /**\n   * Create the https.Agent or http.Agent according to the request schema.\n   */\n  getAgent: function getAgent(useSSL, agentOptions) {\n    var http = useSSL ? require('https') : require('http');\n    if (useSSL) {\n      if (!AWS.NodeHttpClient.sslAgent) {\n        AWS.NodeHttpClient.sslAgent = new http.Agent(AWS.util.merge({\n          rejectUnauthorized: process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0' ? false : true\n        }, agentOptions || {}));\n        AWS.NodeHttpClient.sslAgent.setMaxListeners(0);\n\n        // delegate maxSockets to globalAgent, set a default limit of 50 if current value is Infinity.\n        // Users can bypass this default by supplying their own Agent as part of SDK configuration.\n        Object.defineProperty(AWS.NodeHttpClient.sslAgent, 'maxSockets', {\n          enumerable: true,\n          get: function () {\n            var defaultMaxSockets = 50;\n            var globalAgent = http.globalAgent;\n            if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === 'number') {\n              return globalAgent.maxSockets;\n            }\n            return defaultMaxSockets;\n          }\n        });\n      }\n      return AWS.NodeHttpClient.sslAgent;\n    } else {\n      if (!AWS.NodeHttpClient.agent) {\n        AWS.NodeHttpClient.agent = new http.Agent(agentOptions);\n      }\n      return AWS.NodeHttpClient.agent;\n    }\n  },\n  progressStream: function progressStream(stream, totalBytes) {\n    if (typeof TransformStream === 'undefined') {\n      // for node 0.8 there is no streaming progress\n      return;\n    }\n    var loadedBytes = 0;\n    var reporter = new TransformStream();\n    reporter._transform = function (chunk, encoding, callback) {\n      if (chunk) {\n        loadedBytes += chunk.length;\n        stream.emit('sendProgress', {\n          loaded: loadedBytes,\n          total: totalBytes\n        });\n      }\n      callback(null, chunk);\n    };\n    return reporter;\n  },\n  emitter: null\n});\n\n/**\n * @!ignore\n */\n\n/**\n * @api private\n */\nAWS.HttpClient.prototype = AWS.NodeHttpClient.prototype;\n\n/**\n * @api private\n */\nAWS.HttpClient.streamsApiVersion = ReadableStream ? 2 : 1;","map":{"version":3,"names":["AWS","require","Stream","util","stream","TransformStream","Transform","ReadableStream","Readable","CONNECTION_REUSE_ENV_NAME","NodeHttpClient","inherit","handleRequest","httpRequest","httpOptions","callback","errCallback","self","endpoint","pathPrefix","proxy","protocol","hostname","port","Endpoint","useSSL","http","options","host","method","headers","path","update","agent","getAgent","keepAlive","process","env","timeout","request","httpResp","didCallback","emit","statusCode","statusMessage","connectTimeout","connectTimeoutId","on","socket","connecting","setTimeout","abort","error","Error","code","clearTimeout","msg","err","expect","Expect","once","writeBody","body","totalBytes","parseInt","progressStream","pipe","loaded","total","end","agentOptions","sslAgent","Agent","merge","rejectUnauthorized","NODE_TLS_REJECT_UNAUTHORIZED","setMaxListeners","Object","defineProperty","enumerable","get","defaultMaxSockets","globalAgent","maxSockets","Infinity","loadedBytes","reporter","_transform","chunk","encoding","length","emitter","HttpClient","prototype","streamsApiVersion"],"sources":["/home/ryanosull/clarity/clarity-camp/projects/nft-vids/another-ape-client/node_modules/aws-sdk/lib/http/node.js"],"sourcesContent":["var AWS = require('../core');\nvar Stream = AWS.util.stream.Stream;\nvar TransformStream = AWS.util.stream.Transform;\nvar ReadableStream = AWS.util.stream.Readable;\nrequire('../http');\nvar CONNECTION_REUSE_ENV_NAME = 'AWS_NODEJS_CONNECTION_REUSE_ENABLED';\n\n/**\n * @api private\n */\nAWS.NodeHttpClient = AWS.util.inherit({\n  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {\n    var self = this;\n    var endpoint = httpRequest.endpoint;\n    var pathPrefix = '';\n    if (!httpOptions) httpOptions = {};\n    if (httpOptions.proxy) {\n      pathPrefix = endpoint.protocol + '//' + endpoint.hostname;\n      if (endpoint.port !== 80 && endpoint.port !== 443) {\n        pathPrefix += ':' + endpoint.port;\n      }\n      endpoint = new AWS.Endpoint(httpOptions.proxy);\n    }\n\n    var useSSL = endpoint.protocol === 'https:';\n    var http = useSSL ? require('https') : require('http');\n    var options = {\n      host: endpoint.hostname,\n      port: endpoint.port,\n      method: httpRequest.method,\n      headers: httpRequest.headers,\n      path: pathPrefix + httpRequest.path\n    };\n\n    AWS.util.update(options, httpOptions);\n\n    if (!httpOptions.agent) {\n      options.agent = this.getAgent(useSSL, {\n        keepAlive: process.env[CONNECTION_REUSE_ENV_NAME] === '1' ? true : false\n      });\n    }\n\n    delete options.proxy; // proxy isn't an HTTP option\n    delete options.timeout; // timeout isn't an HTTP option\n\n    var stream = http.request(options, function (httpResp) {\n      if (stream.didCallback) return;\n\n      callback(httpResp);\n      httpResp.emit(\n        'headers',\n        httpResp.statusCode,\n        httpResp.headers,\n        httpResp.statusMessage\n      );\n    });\n    httpRequest.stream = stream; // attach stream to httpRequest\n    stream.didCallback = false;\n\n    // connection timeout support\n    if (httpOptions.connectTimeout) {\n      var connectTimeoutId;\n      stream.on('socket', function(socket) {\n        if (socket.connecting) {\n          connectTimeoutId = setTimeout(function connectTimeout() {\n            if (stream.didCallback) return; stream.didCallback = true;\n\n            stream.abort();\n            errCallback(AWS.util.error(\n              new Error('Socket timed out without establishing a connection'),\n              {code: 'TimeoutError'}\n            ));\n          }, httpOptions.connectTimeout);\n          socket.on('connect', function() {\n            clearTimeout(connectTimeoutId);\n            connectTimeoutId = null;\n          });\n        }\n      });\n    }\n\n    // timeout support\n    stream.setTimeout(httpOptions.timeout || 0, function() {\n      if (stream.didCallback) return; stream.didCallback = true;\n\n      var msg = 'Connection timed out after ' + httpOptions.timeout + 'ms';\n      errCallback(AWS.util.error(new Error(msg), {code: 'TimeoutError'}));\n      stream.abort();\n    });\n\n    stream.on('error', function(err) {\n      if (connectTimeoutId) {\n        clearTimeout(connectTimeoutId);\n        connectTimeoutId = null;\n      }\n      if (stream.didCallback) return; stream.didCallback = true;\n      if ('ECONNRESET' === err.code || 'EPIPE' === err.code || 'ETIMEDOUT' === err.code) {\n        errCallback(AWS.util.error(err, {code: 'TimeoutError'}));\n      } else {\n        errCallback(err);\n      }\n    });\n\n    var expect = httpRequest.headers.Expect || httpRequest.headers.expect;\n    if (expect === '100-continue') {\n      stream.once('continue', function() {\n        self.writeBody(stream, httpRequest);\n      });\n    } else {\n      this.writeBody(stream, httpRequest);\n    }\n\n    return stream;\n  },\n\n  writeBody: function writeBody(stream, httpRequest) {\n    var body = httpRequest.body;\n    var totalBytes = parseInt(httpRequest.headers['Content-Length'], 10);\n\n    if (body instanceof Stream) {\n      // For progress support of streaming content -\n      // pipe the data through a transform stream to emit 'sendProgress' events\n      var progressStream = this.progressStream(stream, totalBytes);\n      if (progressStream) {\n        body.pipe(progressStream).pipe(stream);\n      } else {\n        body.pipe(stream);\n      }\n    } else if (body) {\n      // The provided body is a buffer/string and is already fully available in memory -\n      // For performance it's best to send it as a whole by calling stream.end(body),\n      // Callers expect a 'sendProgress' event which is best emitted once\n      // the http request stream has been fully written and all data flushed.\n      // The use of totalBytes is important over body.length for strings where\n      // length is char length and not byte length.\n      stream.once('finish', function() {\n        stream.emit('sendProgress', {\n          loaded: totalBytes,\n          total: totalBytes\n        });\n      });\n      stream.end(body);\n    } else {\n      // no request body\n      stream.end();\n    }\n  },\n\n  /**\n   * Create the https.Agent or http.Agent according to the request schema.\n   */\n  getAgent: function getAgent(useSSL, agentOptions) {\n    var http = useSSL ? require('https') : require('http');\n    if (useSSL) {\n      if (!AWS.NodeHttpClient.sslAgent) {\n        AWS.NodeHttpClient.sslAgent = new http.Agent(AWS.util.merge({\n          rejectUnauthorized: process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0' ? false : true\n        }, agentOptions || {}));\n        AWS.NodeHttpClient.sslAgent.setMaxListeners(0);\n\n        // delegate maxSockets to globalAgent, set a default limit of 50 if current value is Infinity.\n        // Users can bypass this default by supplying their own Agent as part of SDK configuration.\n        Object.defineProperty(AWS.NodeHttpClient.sslAgent, 'maxSockets', {\n          enumerable: true,\n          get: function() {\n            var defaultMaxSockets = 50;\n            var globalAgent = http.globalAgent;\n            if (globalAgent && globalAgent.maxSockets !== Infinity && typeof globalAgent.maxSockets === 'number') {\n              return globalAgent.maxSockets;\n            }\n            return defaultMaxSockets;\n          }\n        });\n      }\n      return AWS.NodeHttpClient.sslAgent;\n    } else {\n      if (!AWS.NodeHttpClient.agent) {\n        AWS.NodeHttpClient.agent = new http.Agent(agentOptions);\n      }\n      return AWS.NodeHttpClient.agent;\n    }\n  },\n\n  progressStream: function progressStream(stream, totalBytes) {\n    if (typeof TransformStream === 'undefined') {\n      // for node 0.8 there is no streaming progress\n      return;\n    }\n    var loadedBytes = 0;\n    var reporter = new TransformStream();\n    reporter._transform = function(chunk, encoding, callback) {\n      if (chunk) {\n        loadedBytes += chunk.length;\n        stream.emit('sendProgress', {\n          loaded: loadedBytes,\n          total: totalBytes\n        });\n      }\n      callback(null, chunk);\n    };\n    return reporter;\n  },\n\n  emitter: null\n});\n\n/**\n * @!ignore\n */\n\n/**\n * @api private\n */\nAWS.HttpClient.prototype = AWS.NodeHttpClient.prototype;\n\n/**\n * @api private\n */\nAWS.HttpClient.streamsApiVersion = ReadableStream ? 2 : 1;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}