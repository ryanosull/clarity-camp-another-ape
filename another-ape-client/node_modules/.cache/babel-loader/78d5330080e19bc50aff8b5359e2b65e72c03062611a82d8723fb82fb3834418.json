{"ast":null,"code":"import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, concatBytes, utf8ToBytes } from '@stacks/common';\nimport { ClarityType, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv } from './keys';\nexport const STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);\nexport function hashStructuredData(structuredData) {\n  return sha256(serializeCV(structuredData));\n}\nconst hash256BytesLength = 32;\nfunction isDomain(value) {\n  if (value.type !== ClarityType.Tuple) return false;\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII)) return false;\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\nexport function encodeStructuredData({\n  message,\n  domain\n}) {\n  const structuredDataHash = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\");\n  }\n  const domainHash = hashStructuredData(domain);\n  return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);\n}\nexport function decodeStructuredDataSignature(signature) {\n  const encodedMessageBytes = typeof signature === 'string' ? utf8ToBytes(signature) : signature;\n  const domainHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length, STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  return {\n    domainHash,\n    messageHash\n  };\n}\nexport function signStructuredData({\n  message,\n  domain,\n  privateKey\n}) {\n  const structuredDataHash = bytesToHex(sha256(encodeStructuredData({\n    message,\n    domain\n  })));\n  const {\n    data\n  } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature\n  };\n}","map":{"version":3,"names":["sha256","bytesToHex","concatBytes","utf8ToBytes","ClarityType","serializeCV","StacksMessageType","signMessageHashRsv","STRUCTURED_DATA_PREFIX","Uint8Array","hashStructuredData","structuredData","hash256BytesLength","isDomain","value","type","Tuple","every","key","data","StringASCII","UInt","encodeStructuredData","message","domain","structuredDataHash","Error","domainHash","decodeStructuredDataSignature","signature","encodedMessageBytes","slice","length","messageHash","signStructuredData","privateKey","StructuredDataSignature"],"sources":["/home/ryanosull/clarity/clarity-camp/projects/nft-vids/another-ape-client/node_modules/@stacks/transactions/src/structuredDataSignature.ts"],"sourcesContent":["import { sha256 } from '@noble/hashes/sha256';\nimport { bytesToHex, concatBytes, utf8ToBytes } from '@stacks/common';\n\nimport { ClarityType, ClarityValue, serializeCV } from './clarity';\nimport { StacksMessageType } from './constants';\nimport { signMessageHashRsv, StacksPrivateKey } from './keys';\n\n// Refer to SIP018 https://github.com/stacksgov/sips/\n// > asciiToBytes('SIP018')\nexport const STRUCTURED_DATA_PREFIX = new Uint8Array([0x53, 0x49, 0x50, 0x30, 0x31, 0x38]);\n\nexport function hashStructuredData(structuredData: ClarityValue): Uint8Array {\n  return sha256(serializeCV(structuredData));\n}\n\nconst hash256BytesLength = 32;\n\nfunction isDomain(value: ClarityValue): boolean {\n  if (value.type !== ClarityType.Tuple) return false;\n  // Check that the tuple has at least 'name', 'version' and 'chain-id'\n  if (!['name', 'version', 'chain-id'].every(key => key in value.data)) return false;\n  // Check each key is of the right type\n  if (!['name', 'version'].every(key => value.data[key].type === ClarityType.StringASCII))\n    return false;\n\n  if (value.data['chain-id'].type !== ClarityType.UInt) return false;\n  return true;\n}\n\nexport function encodeStructuredData({\n  message,\n  domain,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n}): Uint8Array {\n  const structuredDataHash: Uint8Array = hashStructuredData(message);\n  if (!isDomain(domain)) {\n    throw new Error(\n      \"domain parameter must be a valid domain of type TupleCV with keys 'name', 'version', 'chain-id' with respective types StringASCII, StringASCII, UInt\"\n    );\n  }\n  const domainHash: Uint8Array = hashStructuredData(domain);\n\n  return concatBytes(STRUCTURED_DATA_PREFIX, domainHash, structuredDataHash);\n}\n\nexport type DecodedStructuredData = {\n  domainHash: Uint8Array;\n  messageHash: Uint8Array;\n};\n\nexport function decodeStructuredDataSignature(\n  signature: string | Uint8Array\n): DecodedStructuredData {\n  const encodedMessageBytes: Uint8Array =\n    typeof signature === 'string' ? utf8ToBytes(signature) : signature;\n  const domainHash = encodedMessageBytes.slice(\n    STRUCTURED_DATA_PREFIX.length,\n    STRUCTURED_DATA_PREFIX.length + hash256BytesLength\n  );\n  const messageHash = encodedMessageBytes.slice(STRUCTURED_DATA_PREFIX.length + hash256BytesLength);\n  return {\n    domainHash,\n    messageHash,\n  };\n}\n\nexport interface StructuredDataSignature {\n  readonly type: StacksMessageType.StructuredDataSignature;\n  data: string;\n}\n\n/**\n * Signs a structured message (ClarityValue) and a domain (ClarityValue) using a private key.\n * The resulting signature along with the original message can be verified using {@link verifyMessageSignature}\n * @returns A recoverable signature (in RSV order)\n */\nexport function signStructuredData({\n  message,\n  domain,\n  privateKey,\n}: {\n  message: ClarityValue;\n  domain: ClarityValue;\n  privateKey: StacksPrivateKey;\n}): StructuredDataSignature {\n  const structuredDataHash: string = bytesToHex(sha256(encodeStructuredData({ message, domain })));\n\n  const { data } = signMessageHashRsv({\n    messageHash: structuredDataHash,\n    privateKey,\n  });\n  return {\n    data,\n    type: StacksMessageType.StructuredDataSignature,\n  };\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,sBAAsB;AAC7C,SAASC,UAAU,EAAEC,WAAW,EAAEC,WAAW,QAAQ,gBAAgB;AAErE,SAASC,WAAW,EAAgBC,WAAW,QAAQ,WAAW;AAClE,SAASC,iBAAiB,QAAQ,aAAa;AAC/C,SAASC,kBAAkB,QAA0B,QAAQ;AAI7D,OAAO,MAAMC,sBAAsB,GAAG,IAAIC,UAAU,CAAC,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;AAE1F,OAAM,SAAUC,kBAAkBA,CAACC,cAA4B;EAC7D,OAAOX,MAAM,CAACK,WAAW,CAACM,cAAc,CAAC,CAAC;AAC5C;AAEA,MAAMC,kBAAkB,GAAG,EAAE;AAE7B,SAASC,QAAQA,CAACC,KAAmB;EACnC,IAAIA,KAAK,CAACC,IAAI,KAAKX,WAAW,CAACY,KAAK,EAAE,OAAO,KAAK;EAElD,IAAI,CAAC,CAAC,MAAM,EAAE,SAAS,EAAE,UAAU,CAAC,CAACC,KAAK,CAACC,GAAG,IAAIA,GAAG,IAAIJ,KAAK,CAACK,IAAI,CAAC,EAAE,OAAO,KAAK;EAElF,IAAI,CAAC,CAAC,MAAM,EAAE,SAAS,CAAC,CAACF,KAAK,CAACC,GAAG,IAAIJ,KAAK,CAACK,IAAI,CAACD,GAAG,CAAC,CAACH,IAAI,KAAKX,WAAW,CAACgB,WAAW,CAAC,EACrF,OAAO,KAAK;EAEd,IAAIN,KAAK,CAACK,IAAI,CAAC,UAAU,CAAC,CAACJ,IAAI,KAAKX,WAAW,CAACiB,IAAI,EAAE,OAAO,KAAK;EAClE,OAAO,IAAI;AACb;AAEA,OAAM,SAAUC,oBAAoBA,CAAC;EACnCC,OAAO;EACPC;AAAM,CAIP;EACC,MAAMC,kBAAkB,GAAef,kBAAkB,CAACa,OAAO,CAAC;EAClE,IAAI,CAACV,QAAQ,CAACW,MAAM,CAAC,EAAE;IACrB,MAAM,IAAIE,KAAK,CACb,sJAAsJ,CACvJ;;EAEH,MAAMC,UAAU,GAAejB,kBAAkB,CAACc,MAAM,CAAC;EAEzD,OAAOtB,WAAW,CAACM,sBAAsB,EAAEmB,UAAU,EAAEF,kBAAkB,CAAC;AAC5E;AAOA,OAAM,SAAUG,6BAA6BA,CAC3CC,SAA8B;EAE9B,MAAMC,mBAAmB,GACvB,OAAOD,SAAS,KAAK,QAAQ,GAAG1B,WAAW,CAAC0B,SAAS,CAAC,GAAGA,SAAS;EACpE,MAAMF,UAAU,GAAGG,mBAAmB,CAACC,KAAK,CAC1CvB,sBAAsB,CAACwB,MAAM,EAC7BxB,sBAAsB,CAACwB,MAAM,GAAGpB,kBAAkB,CACnD;EACD,MAAMqB,WAAW,GAAGH,mBAAmB,CAACC,KAAK,CAACvB,sBAAsB,CAACwB,MAAM,GAAGpB,kBAAkB,CAAC;EACjG,OAAO;IACLe,UAAU;IACVM;GACD;AACH;AAYA,OAAM,SAAUC,kBAAkBA,CAAC;EACjCX,OAAO;EACPC,MAAM;EACNW;AAAU,CAKX;EACC,MAAMV,kBAAkB,GAAWxB,UAAU,CAACD,MAAM,CAACsB,oBAAoB,CAAC;IAAEC,OAAO;IAAEC;EAAM,CAAE,CAAC,CAAC,CAAC;EAEhG,MAAM;IAAEL;EAAI,CAAE,GAAGZ,kBAAkB,CAAC;IAClC0B,WAAW,EAAER,kBAAkB;IAC/BU;GACD,CAAC;EACF,OAAO;IACLhB,IAAI;IACJJ,IAAI,EAAET,iBAAiB,CAAC8B;GACzB;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}