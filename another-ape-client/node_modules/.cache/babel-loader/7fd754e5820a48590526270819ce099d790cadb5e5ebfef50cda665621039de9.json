{"ast":null,"code":"var util = require('../core').util;\nvar Transform = require('stream').Transform;\nvar allocBuffer = util.buffer.alloc;\n\n/** @type {Transform} */\nfunction EventMessageChunkerStream(options) {\n  Transform.call(this, options);\n  this.currentMessageTotalLength = 0;\n  this.currentMessagePendingLength = 0;\n  /** @type {Buffer} */\n  this.currentMessage = null;\n\n  /** @type {Buffer} */\n  this.messageLengthBuffer = null;\n}\nEventMessageChunkerStream.prototype = Object.create(Transform.prototype);\n\n/**\n *\n * @param {Buffer} chunk\n * @param {string} encoding\n * @param {*} callback\n */\nEventMessageChunkerStream.prototype._transform = function (chunk, encoding, callback) {\n  var chunkLength = chunk.length;\n  var currentOffset = 0;\n  while (currentOffset < chunkLength) {\n    // create new message if necessary\n    if (!this.currentMessage) {\n      // working on a new message, determine total length\n      var bytesRemaining = chunkLength - currentOffset;\n      // prevent edge case where total length spans 2 chunks\n      if (!this.messageLengthBuffer) {\n        this.messageLengthBuffer = allocBuffer(4);\n      }\n      var numBytesForTotal = Math.min(4 - this.currentMessagePendingLength,\n      // remaining bytes to fill the messageLengthBuffer\n      bytesRemaining // bytes left in chunk\n      );\n\n      chunk.copy(this.messageLengthBuffer, this.currentMessagePendingLength, currentOffset, currentOffset + numBytesForTotal);\n      this.currentMessagePendingLength += numBytesForTotal;\n      currentOffset += numBytesForTotal;\n      if (this.currentMessagePendingLength < 4) {\n        // not enough information to create the current message\n        break;\n      }\n      this.allocateMessage(this.messageLengthBuffer.readUInt32BE(0));\n      this.messageLengthBuffer = null;\n    }\n\n    // write data into current message\n    var numBytesToWrite = Math.min(this.currentMessageTotalLength - this.currentMessagePendingLength,\n    // number of bytes left to complete message\n    chunkLength - currentOffset // number of bytes left in the original chunk\n    );\n\n    chunk.copy(this.currentMessage,\n    // target buffer\n    this.currentMessagePendingLength,\n    // target offset\n    currentOffset,\n    // chunk offset\n    currentOffset + numBytesToWrite // chunk end to write\n    );\n\n    this.currentMessagePendingLength += numBytesToWrite;\n    currentOffset += numBytesToWrite;\n\n    // check if a message is ready to be pushed\n    if (this.currentMessageTotalLength && this.currentMessageTotalLength === this.currentMessagePendingLength) {\n      // push out the message\n      this.push(this.currentMessage);\n      // cleanup\n      this.currentMessage = null;\n      this.currentMessageTotalLength = 0;\n      this.currentMessagePendingLength = 0;\n    }\n  }\n  callback();\n};\nEventMessageChunkerStream.prototype._flush = function (callback) {\n  if (this.currentMessageTotalLength) {\n    if (this.currentMessageTotalLength === this.currentMessagePendingLength) {\n      callback(null, this.currentMessage);\n    } else {\n      callback(new Error('Truncated event message received.'));\n    }\n  } else {\n    callback();\n  }\n};\n\n/**\n * @param {number} size Size of the message to be allocated.\n * @api private\n */\nEventMessageChunkerStream.prototype.allocateMessage = function (size) {\n  if (typeof size !== 'number') {\n    throw new Error('Attempted to allocate an event message where size was not a number: ' + size);\n  }\n  this.currentMessageTotalLength = size;\n  this.currentMessagePendingLength = 4;\n  this.currentMessage = allocBuffer(size);\n  this.currentMessage.writeUInt32BE(size, 0);\n};\n\n/**\n * @api private\n */\nmodule.exports = {\n  EventMessageChunkerStream: EventMessageChunkerStream\n};","map":{"version":3,"names":["util","require","Transform","allocBuffer","buffer","alloc","EventMessageChunkerStream","options","call","currentMessageTotalLength","currentMessagePendingLength","currentMessage","messageLengthBuffer","prototype","Object","create","_transform","chunk","encoding","callback","chunkLength","length","currentOffset","bytesRemaining","numBytesForTotal","Math","min","copy","allocateMessage","readUInt32BE","numBytesToWrite","push","_flush","Error","size","writeUInt32BE","module","exports"],"sources":["/home/ryanosull/clarity/clarity-camp/projects/nft-vids/another-ape-client/node_modules/aws-sdk/lib/event-stream/event-message-chunker-stream.js"],"sourcesContent":["var util = require('../core').util;\nvar Transform = require('stream').Transform;\nvar allocBuffer = util.buffer.alloc;\n\n/** @type {Transform} */\nfunction EventMessageChunkerStream(options) {\n    Transform.call(this, options);\n\n    this.currentMessageTotalLength = 0;\n    this.currentMessagePendingLength = 0;\n    /** @type {Buffer} */\n    this.currentMessage = null;\n\n    /** @type {Buffer} */\n    this.messageLengthBuffer = null;\n}\n\nEventMessageChunkerStream.prototype = Object.create(Transform.prototype);\n\n/**\n *\n * @param {Buffer} chunk\n * @param {string} encoding\n * @param {*} callback\n */\nEventMessageChunkerStream.prototype._transform = function(chunk, encoding, callback) {\n    var chunkLength = chunk.length;\n    var currentOffset = 0;\n\n    while (currentOffset < chunkLength) {\n        // create new message if necessary\n        if (!this.currentMessage) {\n            // working on a new message, determine total length\n            var bytesRemaining = chunkLength - currentOffset;\n            // prevent edge case where total length spans 2 chunks\n            if (!this.messageLengthBuffer) {\n                this.messageLengthBuffer = allocBuffer(4);\n            }\n            var numBytesForTotal = Math.min(\n                4 - this.currentMessagePendingLength, // remaining bytes to fill the messageLengthBuffer\n                bytesRemaining // bytes left in chunk\n            );\n\n            chunk.copy(\n                this.messageLengthBuffer,\n                this.currentMessagePendingLength,\n                currentOffset,\n                currentOffset + numBytesForTotal\n            );\n\n            this.currentMessagePendingLength += numBytesForTotal;\n            currentOffset += numBytesForTotal;\n\n            if (this.currentMessagePendingLength < 4) {\n                // not enough information to create the current message\n                break;\n            }\n            this.allocateMessage(this.messageLengthBuffer.readUInt32BE(0));\n            this.messageLengthBuffer = null;\n        }\n\n        // write data into current message\n        var numBytesToWrite = Math.min(\n            this.currentMessageTotalLength - this.currentMessagePendingLength, // number of bytes left to complete message\n            chunkLength - currentOffset // number of bytes left in the original chunk\n        );\n        chunk.copy(\n            this.currentMessage, // target buffer\n            this.currentMessagePendingLength, // target offset\n            currentOffset, // chunk offset\n            currentOffset + numBytesToWrite // chunk end to write\n        );\n        this.currentMessagePendingLength += numBytesToWrite;\n        currentOffset += numBytesToWrite;\n\n        // check if a message is ready to be pushed\n        if (this.currentMessageTotalLength && this.currentMessageTotalLength === this.currentMessagePendingLength) {\n            // push out the message\n            this.push(this.currentMessage);\n            // cleanup\n            this.currentMessage = null;\n            this.currentMessageTotalLength = 0;\n            this.currentMessagePendingLength = 0;\n        }\n    }\n\n    callback();\n};\n\nEventMessageChunkerStream.prototype._flush = function(callback) {\n    if (this.currentMessageTotalLength) {\n        if (this.currentMessageTotalLength === this.currentMessagePendingLength) {\n            callback(null, this.currentMessage);\n        } else {\n            callback(new Error('Truncated event message received.'));\n        }\n    } else {\n        callback();\n    }\n};\n\n/**\n * @param {number} size Size of the message to be allocated.\n * @api private\n */\nEventMessageChunkerStream.prototype.allocateMessage = function(size) {\n    if (typeof size !== 'number') {\n        throw new Error('Attempted to allocate an event message where size was not a number: ' + size);\n    }\n    this.currentMessageTotalLength = size;\n    this.currentMessagePendingLength = 4;\n    this.currentMessage = allocBuffer(size);\n    this.currentMessage.writeUInt32BE(size, 0);\n};\n\n/**\n * @api private\n */\nmodule.exports = {\n    EventMessageChunkerStream: EventMessageChunkerStream\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}