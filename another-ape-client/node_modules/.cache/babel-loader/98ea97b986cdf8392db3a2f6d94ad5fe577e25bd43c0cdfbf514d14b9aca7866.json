{"ast":null,"code":"import { AppConfig } from './appConfig';\nimport { InstanceDataStore, LocalStorageStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport { decryptContent, encryptContent, isValidPrivateKey } from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport { BLOCKSTACK_DEFAULT_GAIA_HUB_URL, getGlobalObject, InvalidStateError, isLaterVersion, Logger, LoginFailedError, MissingParameterError, nextHour } from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { DEFAULT_PROFILE } from './constants';\nimport { createFetchFn, StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\nexport class UserSession {\n  constructor(options) {\n    let runningInBrowser = true;\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      runningInBrowser = false;\n    }\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n  makeAuthRequestToken(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt = nextHour().getTime(), extraParams = {}) {\n    const appConfig = this.appConfig;\n    if (!appConfig) {\n      throw new InvalidStateError('Missing AppConfig');\n    }\n    transitKey = transitKey || this.generateAndStoreTransitKey();\n    redirectURI = redirectURI || appConfig.redirectURI();\n    manifestURI = manifestURI || appConfig.manifestURI();\n    scopes = scopes || appConfig.scopes;\n    appDomain = appDomain || appConfig.appDomain;\n    return authMessages.makeAuthRequestToken(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);\n  }\n  generateAndStoreTransitKey() {\n    const sessionData = this.store.getSessionData();\n    const transitKey = authMessages.generateTransitKey();\n    sessionData.transitKey = transitKey;\n    this.store.setSessionData(sessionData);\n    return transitKey;\n  }\n  getAuthResponseToken() {\n    const search = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'getAuthResponseToken'\n    })?.search;\n    const params = new URLSearchParams(search);\n    return params.get('authResponse') ?? '';\n  }\n  isSignInPending() {\n    try {\n      const isProtocolEcho = protocolEchoReplyDetection();\n      if (isProtocolEcho) {\n        Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n        return true;\n      }\n    } catch (error) {\n      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n    return !!this.getAuthResponseToken();\n  }\n  isUserSignedIn() {\n    return !!this.store.getSessionData().userData;\n  }\n  async handlePendingSignIn(authResponseToken = this.getAuthResponseToken(), fetchFn = createFetchFn()) {\n    const sessionData = this.store.getSessionData();\n    if (sessionData.userData) {\n      throw new LoginFailedError('Existing user session found.');\n    }\n    const transitKey = this.store.getSessionData().transitKey;\n    let coreNode = this.appConfig && this.appConfig.coreNode;\n    if (!coreNode) {\n      const network = new StacksMainnet();\n      coreNode = network.bnsLookupUrl;\n    }\n    const tokenPayload = decodeToken(authResponseToken).payload;\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n    const isValid = await verifyAuthResponse(authResponseToken);\n    if (!isValid) {\n      throw new LoginFailedError('Invalid authentication response.');\n    }\n    let appPrivateKey = tokenPayload.private_key;\n    let coreSessionToken = tokenPayload.core_token;\n    if (isLaterVersion(tokenPayload.version, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = await authMessages.decryptPrivateKey(transitKey, tokenPayload.private_key);\n          } catch (e) {\n            Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n            if (!isValidPrivateKey(tokenPayload.private_key)) {\n              throw new LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n            }\n          }\n        }\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = await authMessages.decryptPrivateKey(transitKey, coreSessionToken);\n          } catch (e) {\n            Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n      }\n    }\n    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken;\n    if (isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n      hubUrl = tokenPayload.hubUrl;\n    }\n    if (isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n      gaiaAssociationToken = tokenPayload.associationToken;\n    }\n    const userData = {\n      profile: tokenPayload.profile,\n      email: tokenPayload.email,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      appPrivateKeyFromWalletSalt: tokenPayload.appPrivateKeyFromWalletSalt,\n      coreNode: tokenPayload.blockstackAPIUrl,\n      gaiaAssociationToken\n    };\n    const profileURL = tokenPayload.profile_url;\n    if (!userData.profile && profileURL) {\n      const response = await fetchFn(profileURL);\n      if (!response.ok) {\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = await response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        userData.profile = extractProfile(wrappedProfile[0].token);\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n    sessionData.userData = userData;\n    this.store.setSessionData(sessionData);\n    return userData;\n  }\n  loadUserData() {\n    const userData = this.store.getSessionData().userData;\n    if (!userData) {\n      throw new InvalidStateError('No user data found. Did the user sign in?');\n    }\n    return userData;\n  }\n  encryptContent(content, options) {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return encryptContent(content, opts);\n  }\n  decryptContent(content, options) {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return decryptContent(content, opts);\n  }\n  signUserOut(redirectURL) {\n    this.store.deleteSessionData();\n    if (redirectURL) {\n      if (typeof location !== 'undefined' && location.href) {\n        location.href = redirectURL;\n      }\n    }\n  }\n}\nUserSession.prototype.makeAuthRequest = UserSession.prototype.makeAuthRequestToken;","map":{"version":3,"names":["AppConfig","InstanceDataStore","LocalStorageStore","decodeToken","verifyAuthResponse","authMessages","decryptContent","encryptContent","isValidPrivateKey","getAddressFromDID","BLOCKSTACK_DEFAULT_GAIA_HUB_URL","getGlobalObject","InvalidStateError","isLaterVersion","Logger","LoginFailedError","MissingParameterError","nextHour","extractProfile","DEFAULT_PROFILE","createFetchFn","StacksMainnet","protocolEchoReplyDetection","UserSession","constructor","options","runningInBrowser","window","self","appConfig","sessionStore","store","sessionOptions","makeAuthRequestToken","transitKey","redirectURI","manifestURI","scopes","appDomain","expiresAt","getTime","extraParams","generateAndStoreTransitKey","sessionData","getSessionData","generateTransitKey","setSessionData","getAuthResponseToken","search","throwIfUnavailable","usageDesc","params","URLSearchParams","get","isSignInPending","isProtocolEcho","info","error","isUserSignedIn","userData","handlePendingSignIn","authResponseToken","fetchFn","coreNode","network","bnsLookupUrl","tokenPayload","payload","Error","isValid","appPrivateKey","private_key","coreSessionToken","core_token","version","undefined","decryptPrivateKey","e","warn","hubUrl","gaiaAssociationToken","associationToken","profile","email","decentralizedID","iss","identityAddress","appPrivateKeyFromWalletSalt","blockstackAPIUrl","profileURL","profile_url","response","ok","Object","assign","responseText","text","wrappedProfile","JSON","parse","token","loadUserData","content","opts","privateKey","signUserOut","redirectURL","deleteSessionData","location","href","prototype","makeAuthRequest"],"sources":["/home/ryanosull/clarity/clarity-camp/projects/nft-vids/another-ape-client/node_modules/@stacks/auth/src/userSession.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\n// todo: fix eslint rule, rename UserSession?\nimport { AppConfig } from './appConfig';\nimport { SessionOptions } from './sessionData';\nimport { InstanceDataStore, LocalStorageStore, SessionDataStore } from './sessionStore';\nimport { decodeToken } from 'jsontokens';\nimport { verifyAuthResponse } from './verification';\nimport * as authMessages from './messages';\nimport {\n  decryptContent,\n  encryptContent,\n  EncryptContentOptions,\n  isValidPrivateKey,\n} from '@stacks/encryption';\nimport { getAddressFromDID } from './dids';\nimport {\n  BLOCKSTACK_DEFAULT_GAIA_HUB_URL,\n  getGlobalObject,\n  InvalidStateError,\n  isLaterVersion,\n  Logger,\n  LoginFailedError,\n  MissingParameterError,\n  nextHour,\n} from '@stacks/common';\nimport { extractProfile } from '@stacks/profile';\nimport { AuthScope, DEFAULT_PROFILE } from './constants';\n\nimport { UserData } from './userData';\nimport { createFetchFn, FetchFn, StacksMainnet } from '@stacks/network';\nimport { protocolEchoReplyDetection } from './protocolEchoDetection';\n\n/**\n *\n * Represents an instance of a signed in user for a particular app.\n *\n * A signed in user has access to two major pieces of information\n * about the user, the user's private key for that app and the location\n * of the user's gaia storage bucket for the app.\n *\n * A user can be signed in either directly through the interactive\n * sign in process or by directly providing the app private key.\n *\n\n *\n */\nexport class UserSession {\n  appConfig: AppConfig;\n\n  store: SessionDataStore;\n\n  /**\n   * Creates a UserSession object\n   *\n   * @param options\n   */\n  constructor(options?: {\n    appConfig?: AppConfig;\n    sessionStore?: SessionDataStore;\n    sessionOptions?: SessionOptions;\n  }) {\n    let runningInBrowser = true;\n\n    if (typeof window === 'undefined' && typeof self === 'undefined') {\n      // Logger.debug('UserSession: not running in browser')\n      runningInBrowser = false;\n    }\n\n    if (options && options.appConfig) {\n      this.appConfig = options.appConfig;\n    } else if (runningInBrowser) {\n      this.appConfig = new AppConfig();\n    } else {\n      throw new MissingParameterError('You need to specify options.appConfig');\n    }\n\n    if (options && options.sessionStore) {\n      this.store = options.sessionStore;\n    } else if (runningInBrowser) {\n      if (options) {\n        this.store = new LocalStorageStore(options.sessionOptions);\n      } else {\n        this.store = new LocalStorageStore();\n      }\n    } else if (options) {\n      this.store = new InstanceDataStore(options.sessionOptions);\n    } else {\n      this.store = new InstanceDataStore();\n    }\n  }\n\n  /**\n   * Generates an authentication request that can be sent to the Blockstack\n   * browser for the user to approve sign in. This authentication request can\n   * then be used for sign in by passing it to the [[redirectToSignInWithAuthRequest]]\n   * method.\n   *\n   * *Note*: This method should only be used if you want to use a customized authentication\n   * flow. Typically, you'd use [[redirectToSignIn]] which is the default sign in method.\n   *\n   * @param transitKey A HEX encoded transit private key.\n   * @param redirectURI Location to redirect the user to after sign in approval.\n   * @param manifestURI Location of this app's manifest file.\n   * @param scopes The permissions this app is requesting. The default is `store_write`.\n   * @param appDomain The origin of the app.\n   * @param expiresAt The time at which this request is no longer valid.\n   * @param extraParams Any extra parameters to pass to the authenticator. Use this to\n   * pass options that aren't part of the Blockstack authentication specification,\n   * but might be supported by special authenticators.\n   *\n   * @returns {String} the authentication request token\n   */\n  makeAuthRequestToken(\n    transitKey?: string,\n    redirectURI?: string,\n    manifestURI?: string,\n    scopes?: (AuthScope | string)[],\n    appDomain?: string,\n    expiresAt: number = nextHour().getTime(),\n    extraParams: any = {}\n  ): string {\n    const appConfig = this.appConfig;\n    if (!appConfig) {\n      throw new InvalidStateError('Missing AppConfig');\n    }\n    transitKey = transitKey || this.generateAndStoreTransitKey();\n    redirectURI = redirectURI || appConfig.redirectURI();\n    manifestURI = manifestURI || appConfig.manifestURI();\n    scopes = scopes || appConfig.scopes;\n    appDomain = appDomain || appConfig.appDomain;\n    return authMessages.makeAuthRequestToken(\n      transitKey,\n      redirectURI,\n      manifestURI,\n      scopes,\n      appDomain,\n      expiresAt,\n      extraParams\n    );\n  }\n\n  /**\n   * Generates a ECDSA keypair to\n   * use as the ephemeral app transit private key\n   * and store in the session.\n   *\n   * @returns {String} the hex encoded private key\n   *\n   */\n  generateAndStoreTransitKey(): string {\n    const sessionData = this.store.getSessionData();\n    const transitKey = authMessages.generateTransitKey();\n    sessionData.transitKey = transitKey;\n    this.store.setSessionData(sessionData);\n    return transitKey;\n  }\n\n  /**\n   * Retrieve the authentication token from the URL query\n   * @return {String} the authentication token if it exists otherwise `null`\n   */\n  getAuthResponseToken(): string {\n    const search = getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'getAuthResponseToken',\n    })?.search;\n\n    const params = new URLSearchParams(search);\n    return params.get('authResponse') ?? '';\n  }\n\n  /**\n   * Check if there is a authentication request that hasn't been handled.\n   *\n   * Also checks for a protocol echo reply (which if detected then the page\n   * will be automatically redirected after this call).\n   *\n   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n   */\n  isSignInPending() {\n    try {\n      const isProtocolEcho = protocolEchoReplyDetection();\n      if (isProtocolEcho) {\n        Logger.info(\n          'protocolEchoReply detected from isSignInPending call, the page is about to redirect.'\n        );\n        return true;\n      }\n    } catch (error) {\n      Logger.error(`Error checking for protocol echo reply isSignInPending: ${error}`);\n    }\n\n    return !!this.getAuthResponseToken();\n  }\n\n  /**\n   * Check if a user is currently signed in.\n   *\n   * @returns {Boolean} `true` if the user is signed in, `false` if not.\n   */\n  isUserSignedIn() {\n    return !!this.store.getSessionData().userData;\n  }\n\n  /**\n   * Try to process any pending sign in request by returning a `Promise` that resolves\n   * to the user data object if the sign in succeeds.\n   *\n   * @param {String} authResponseToken - the signed authentication response token\n   * @returns {Promise} that resolves to the user data object if successful and rejects\n   * if handling the sign in request fails or there was no pending sign in request.\n   */\n  async handlePendingSignIn(\n    authResponseToken: string = this.getAuthResponseToken(),\n    fetchFn: FetchFn = createFetchFn()\n  ): Promise<UserData> {\n    const sessionData = this.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new LoginFailedError('Existing user session found.');\n    }\n\n    const transitKey = this.store.getSessionData().transitKey;\n\n    // let nameLookupURL;\n    let coreNode = this.appConfig && this.appConfig.coreNode;\n    if (!coreNode) {\n      const network = new StacksMainnet();\n      coreNode = network.bnsLookupUrl;\n    }\n\n    const tokenPayload = decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    const isValid = await verifyAuthResponse(authResponseToken);\n    if (!isValid) {\n      throw new LoginFailedError('Invalid authentication response.');\n    }\n\n    // TODO: real version handling\n    let appPrivateKey: string = tokenPayload.private_key as string;\n    let coreSessionToken: string = tokenPayload.core_token as string;\n    if (isLaterVersion(tokenPayload.version as string, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = (await authMessages.decryptPrivateKey(\n              transitKey,\n              tokenPayload.private_key as string\n            )) as string;\n          } catch (e) {\n            Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n            if (!isValidPrivateKey(tokenPayload.private_key as string)) {\n              throw new LoginFailedError(\n                'Failed decrypting appPrivateKey. Usually means' +\n                  ' that the transit key has changed during login.'\n              );\n            }\n          }\n        }\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = (await authMessages.decryptPrivateKey(\n              transitKey,\n              coreSessionToken\n            )) as string;\n          } catch (e) {\n            Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new LoginFailedError(\n          'Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.'\n        );\n      }\n    }\n    let hubUrl = BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken: string;\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.2.0') &&\n      tokenPayload.hubUrl !== null &&\n      tokenPayload.hubUrl !== undefined\n    ) {\n      hubUrl = tokenPayload.hubUrl as string;\n    }\n    if (\n      isLaterVersion(tokenPayload.version as string, '1.3.0') &&\n      tokenPayload.associationToken !== null &&\n      tokenPayload.associationToken !== undefined\n    ) {\n      gaiaAssociationToken = tokenPayload.associationToken as string;\n    }\n\n    const userData: UserData = {\n      profile: tokenPayload.profile,\n      email: tokenPayload.email as string,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      appPrivateKeyFromWalletSalt: tokenPayload.appPrivateKeyFromWalletSalt as string,\n      coreNode: tokenPayload.blockstackAPIUrl as string,\n      // @ts-expect-error\n      gaiaAssociationToken,\n    };\n    const profileURL = tokenPayload.profile_url as string;\n    if (!userData.profile && profileURL) {\n      const response = await fetchFn(profileURL);\n      if (!response.ok) {\n        // return blank profile if we fail to fetch\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = await response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        userData.profile = extractProfile(wrappedProfile[0].token);\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    this.store.setSessionData(sessionData);\n\n    return userData;\n  }\n\n  /**\n   * Retrieves the user data object. The user's profile is stored in the key [[Profile]].\n   *\n   * @returns {Object} User data object.\n   */\n  loadUserData() {\n    const userData = this.store.getSessionData().userData;\n    if (!userData) {\n      throw new InvalidStateError('No user data found. Did the user sign in?');\n    }\n    return userData;\n  }\n\n  /**\n   * Encrypts the data provided with the app public key.\n   * @param {string | Uint8Array} content  the data to encrypt\n   * @param options\n   * @param {string} options.publicKey the hex string of the ECDSA public\n   * key to use for encryption. If not provided, will use user's appPrivateKey.\n   *\n   * @returns {string} Stringified ciphertext object\n   */\n  encryptContent(content: string | Uint8Array, options?: EncryptContentOptions): Promise<string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return encryptContent(content, opts);\n  }\n\n  /**\n   * Decrypts data encrypted with `encryptContent` with the\n   * transit private key.\n   * @param {string | Uint8Array} content - encrypted content.\n   * @param options\n   * @param {string} options.privateKey - The hex string of the ECDSA private\n   * key to use for decryption. If not provided, will use user's appPrivateKey.\n   * @returns {string | Uint8Array} decrypted content.\n   */\n  decryptContent(content: string, options?: { privateKey?: string }): Promise<Uint8Array | string> {\n    const opts = Object.assign({}, options);\n    if (!opts.privateKey) {\n      opts.privateKey = this.loadUserData().appPrivateKey;\n    }\n    return decryptContent(content, opts);\n  }\n\n  /**\n   * Sign the user out and optionally redirect to given location.\n   * @param  redirectURL\n   * Location to redirect user to after sign out.\n   * Only used in environments with `window` available\n   */\n\n  signUserOut(\n    redirectURL?: string\n    // TODO: this is not used?\n    // caller?: UserSession\n  ) {\n    this.store.deleteSessionData();\n    if (redirectURL) {\n      if (typeof location !== 'undefined' && location.href) {\n        location.href = redirectURL;\n      }\n      // TODO: Invalid left-hand side in assignment expression\n      // // eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n      // // @ts-ignore\n      // getGlobalObject('location', {\n      //   throwIfUnavailable: true,\n      //   usageDesc: 'signUserOut',\n      // })?.href = redirectURL;\n    }\n  }\n}\n\n// Add method aliases for backwards compatibility\nexport interface UserSession {\n  /** @deprecated {@link makeAuthRequest} was renamed to {@link makeAuthRequestToken} */\n  makeAuthRequest(\n    ...args: Parameters<typeof UserSession.prototype.makeAuthRequestToken>\n  ): ReturnType<typeof UserSession.prototype.makeAuthRequestToken>;\n}\n\n// eslint-disable-next-line @typescript-eslint/unbound-method\nUserSession.prototype.makeAuthRequest = UserSession.prototype.makeAuthRequestToken;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}