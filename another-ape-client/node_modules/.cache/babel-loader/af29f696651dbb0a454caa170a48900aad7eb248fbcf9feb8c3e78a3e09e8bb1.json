{"ast":null,"code":"import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, signSync, utils } from '@noble/secp256k1';\nimport { bytesToHex, concatBytes, hexToBytes, privateKeyToBytes, PRIVATE_KEY_COMPRESSED_LENGTH, readUInt8 } from '@stacks/common';\nimport base58 from 'bs58';\nimport { hashRipemd160 } from './hashRipemd160';\nimport { hashSha256Sync } from './sha2Hash';\nconst BITCOIN_PUBKEYHASH = 0x00;\nutils.hmacSha256Sync = (key, ...msgs) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\nexport function makeECPrivateKey() {\n  return bytesToHex(utils.randomPrivateKey());\n}\nexport function base58CheckDecode(btcAddress) {\n  const bytes = base58.decode(btcAddress);\n  const payload = bytes.slice(0, -4);\n  const checksum = bytes.slice(-4);\n  const newChecksum = sha256(sha256(payload));\n  if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) {\n    throw new Error('Invalid checksum');\n  }\n  if (payload.length !== 21) throw new TypeError('Invalid address length');\n  const version = readUInt8(payload, 0);\n  const hash = payload.slice(1);\n  return {\n    version,\n    hash\n  };\n}\nexport function base58Encode(hash) {\n  const checksum = sha256(sha256(hash));\n  return base58.encode(concatBytes(hash, checksum).slice(0, hash.length + 4));\n}\nexport function base58CheckEncode(version, hash) {\n  return base58Encode(concatBytes(new Uint8Array([version]), hash.slice(0, 20)));\n}\nexport function publicKeyToBtcAddress(publicKey, version = BITCOIN_PUBKEYHASH) {\n  const publicKeyBytes = typeof publicKey === 'string' ? hexToBytes(publicKey) : publicKey;\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBytes));\n  return base58CheckEncode(version, publicKeyHash160);\n}\nexport function getPublicKeyFromPrivate(privateKey) {\n  const privateKeyBytes = privateKeyToBytes(privateKey);\n  return bytesToHex(nobleGetPublicKey(privateKeyBytes.slice(0, 32), true));\n}\nexport function ecSign(messageHash, hexPrivateKey) {\n  return signSync(messageHash, privateKeyToBytes(hexPrivateKey).slice(0, 32), {\n    der: false\n  });\n}\nexport function isValidPrivateKey(privateKey) {\n  return utils.isValidPrivateKey(privateKeyToBytes(privateKey));\n}\nexport function compressPrivateKey(privateKey) {\n  const privateKeyBytes = privateKeyToBytes(privateKey);\n  return privateKeyBytes.length == PRIVATE_KEY_COMPRESSED_LENGTH ? privateKeyBytes : concatBytes(privateKeyBytes, new Uint8Array([1]));\n}","map":{"version":3,"names":["hmac","sha256","getPublicKey","nobleGetPublicKey","signSync","utils","bytesToHex","concatBytes","hexToBytes","privateKeyToBytes","PRIVATE_KEY_COMPRESSED_LENGTH","readUInt8","base58","hashRipemd160","hashSha256Sync","BITCOIN_PUBKEYHASH","hmacSha256Sync","key","msgs","h","create","forEach","msg","update","digest","makeECPrivateKey","randomPrivateKey","base58CheckDecode","btcAddress","bytes","decode","payload","slice","checksum","newChecksum","Error","length","TypeError","version","hash","base58Encode","encode","base58CheckEncode","Uint8Array","publicKeyToBtcAddress","publicKey","publicKeyBytes","publicKeyHash160","getPublicKeyFromPrivate","privateKey","privateKeyBytes","ecSign","messageHash","hexPrivateKey","der","isValidPrivateKey","compressPrivateKey"],"sources":["/home/ryanosull/clarity/clarity-camp/projects/nft-vids/another-ape-client/node_modules/@stacks/encryption/src/keys.ts"],"sourcesContent":["import { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { getPublicKey as nobleGetPublicKey, signSync, utils } from '@noble/secp256k1';\nimport {\n  bytesToHex,\n  concatBytes,\n  hexToBytes,\n  privateKeyToBytes,\n  PRIVATE_KEY_COMPRESSED_LENGTH,\n  readUInt8,\n} from '@stacks/common';\nimport base58 from 'bs58';\nimport { hashRipemd160 } from './hashRipemd160';\nimport { hashSha256Sync } from './sha2Hash';\n\nconst BITCOIN_PUBKEYHASH = 0x00;\n\n/**\n * To use secp256k1.signSync set utils.hmacSha256Sync to a function using noble-hashes\n * secp256k1.signSync is the counter part of secp256k1.sign (async version)\n * secp256k1.signSync is used within signWithKey in this file\n * secp256k1.signSync is used to maintain the semantics of signWithKey while migrating from elliptic lib\n * utils.hmacSha256Sync docs: https://github.com/paulmillr/noble-secp256k1 readme file\n */\nutils.hmacSha256Sync = (key: Uint8Array, ...msgs: Uint8Array[]) => {\n  const h = hmac.create(sha256, key);\n  msgs.forEach(msg => h.update(msg));\n  return h.digest();\n};\n\n/**\n * @ignore\n */\nexport function makeECPrivateKey() {\n  return bytesToHex(utils.randomPrivateKey());\n}\n\n/**\n * Based on bitcoinjs-lib MIT https://github.com/bitcoinjs/bs58check/blob/12b3e700f355c5c49d0be3f8fc29be6c66e753e9/base.js\n * @ignore\n */\nexport function base58CheckDecode(btcAddress: string): {\n  version: number;\n  hash: Uint8Array;\n} {\n  const bytes = base58.decode(btcAddress);\n  const payload = bytes.slice(0, -4);\n  const checksum = bytes.slice(-4);\n  const newChecksum = sha256(sha256(payload));\n\n  if (\n    (checksum[0] ^ newChecksum[0]) |\n    (checksum[1] ^ newChecksum[1]) |\n    (checksum[2] ^ newChecksum[2]) |\n    (checksum[3] ^ newChecksum[3])\n  ) {\n    throw new Error('Invalid checksum');\n  }\n\n  if (payload.length !== 21) throw new TypeError('Invalid address length');\n\n  const version = readUInt8(payload, 0);\n  const hash = payload.slice(1);\n\n  return { version, hash };\n}\n\n/**\n * @ignore\n */\nexport function base58Encode(hash: Uint8Array) {\n  const checksum = sha256(sha256(hash));\n  return base58.encode(concatBytes(hash, checksum).slice(0, hash.length + 4));\n}\n\n/**\n * @ignore\n */\nexport function base58CheckEncode(version: number, hash: Uint8Array) {\n  return base58Encode(concatBytes(new Uint8Array([version]), hash.slice(0, 20)));\n}\n\n/**\n * @ignore\n */\nexport function publicKeyToBtcAddress(\n  publicKey: string | Uint8Array,\n  version: number = BITCOIN_PUBKEYHASH\n) {\n  const publicKeyBytes = typeof publicKey === 'string' ? hexToBytes(publicKey) : publicKey;\n  const publicKeyHash160 = hashRipemd160(hashSha256Sync(publicKeyBytes));\n  return base58CheckEncode(version, publicKeyHash160);\n}\n\n/**\n * @ignore\n * @returns a compressed public key\n */\nexport function getPublicKeyFromPrivate(privateKey: string | Uint8Array): string {\n  const privateKeyBytes = privateKeyToBytes(privateKey);\n  // for backwards compatibility we always return a compressed public key, regardless of private key mode\n  return bytesToHex(nobleGetPublicKey(privateKeyBytes.slice(0, 32), true));\n}\n\n/**\n * @ignore\n */\nexport function ecSign(messageHash: Uint8Array, hexPrivateKey: string | Uint8Array) {\n  return signSync(messageHash, privateKeyToBytes(hexPrivateKey).slice(0, 32), {\n    der: false,\n  });\n}\n\n/**\n * @ignore\n */\nexport function isValidPrivateKey(privateKey: string | Uint8Array): boolean {\n  return utils.isValidPrivateKey(privateKeyToBytes(privateKey));\n}\n\n/**\n * @ignore\n */\nexport function compressPrivateKey(privateKey: string | Uint8Array): Uint8Array {\n  const privateKeyBytes = privateKeyToBytes(privateKey);\n\n  return privateKeyBytes.length == PRIVATE_KEY_COMPRESSED_LENGTH\n    ? privateKeyBytes // leave compressed\n    : concatBytes(privateKeyBytes, new Uint8Array([1])); // compress\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}