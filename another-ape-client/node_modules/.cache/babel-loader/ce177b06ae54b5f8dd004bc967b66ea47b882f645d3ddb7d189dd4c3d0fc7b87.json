{"ast":null,"code":"import { bytesToHex, hexToBytes, intToBigInt } from '@stacks/common';\nimport { StacksNetwork, StacksMainnet, StacksTestnet, createFetchFn } from '@stacks/network';\nimport { c32address } from 'c32check';\nimport { createMultiSigSpendingCondition, createSingleSigSpendingCondition, createSponsoredAuth, createStandardAuth } from './authorization';\nimport { deserializeCV, serializeCV } from './clarity';\nimport { AddressHashMode, AddressVersion, PayloadType, PostConditionMode, TransactionVersion, RECOVERABLE_ECDSA_SIG_LENGTH_BYTES, StacksMessageType, ClarityVersion } from './constants';\nimport { validateContractCall } from './contract-abi';\nimport { NoEstimateAvailableError } from './errors';\nimport { createStacksPrivateKey, getPublicKey, pubKeyfromPrivKey, publicKeyFromBytes, publicKeyToAddress, publicKeyToString } from './keys';\nimport { createContractCallPayload, createSmartContractPayload, createTokenTransferPayload, serializePayload } from './payload';\nimport { createFungiblePostCondition, createNonFungiblePostCondition, createSTXPostCondition } from './postcondition';\nimport { createContractPrincipal, createStandardPrincipal } from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\nexport async function getNonce(address, network) {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(`Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText);\n  return BigInt(result.nonce);\n}\nexport async function estimateTransfer(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(`Transaction fee estimation only possible with ${PayloadType[PayloadType.TokenTransfer]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  return estimateTransferUnsafe(transaction, network);\n}\nexport async function estimateTransferUnsafe(transaction, network) {\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\nexport async function estimateTransaction(transactionPayload, estimatedLen, network) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify({\n      transaction_payload: bytesToHex(serializePayload(transactionPayload)),\n      ...(estimatedLen ? {\n        estimated_len: estimatedLen\n      } : {})\n    })\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const body = await response.json().catch(() => ({}));\n    if (body?.reason === 'NoEstimateAvailable') {\n      throw new NoEstimateAvailableError(body?.reason_data?.message ?? '');\n    }\n    throw new Error(`Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${body}\"`);\n  }\n  const data = await response.json();\n  return data.estimations;\n}\nexport async function broadcastTransaction(transaction, network, attachment) {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\nexport async function broadcastRawTransaction(rawTx, url, attachment, fetchFn = createFetchFn()) {\n  const options = {\n    method: 'POST',\n    headers: {\n      'Content-Type': attachment ? 'application/json' : 'application/octet-stream'\n    },\n    body: attachment ? JSON.stringify({\n      tx: bytesToHex(rawTx),\n      attachment: bytesToHex(attachment)\n    }) : rawTx\n  };\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return await response.json();\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${e.message}`);\n    }\n  }\n  const text = await response.text();\n  const txid = text.replace(/[\"]+/g, '');\n  if (!validateTxId(txid)) throw new Error(text);\n  return {\n    txid\n  };\n}\nexport async function getAbi(address, contractName, network) {\n  const options = {\n    method: 'GET'\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  return JSON.parse(await response.text());\n}\nfunction deriveNetwork(transaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\nexport async function makeUnsignedSTXTokenTransfer(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    memo: '',\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n  let authorization = null;\n  let spendingCondition = null;\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const transaction = new StacksTransaction(network.version, authorization, payload, undefined, undefined, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function makeSTXTokenTransfer(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({\n      publicKey,\n      ...options\n    });\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n    return transaction;\n  }\n}\nexport async function estimateContractDeploy(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.SmartContract && transaction.payload.payloadType !== PayloadType.VersionedSmartContract) {\n    throw new Error(`Contract deploy fee estimation only possible with ${PayloadType[PayloadType.SmartContract]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeContractDeploy(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractDeploy({\n      publicKey,\n      ...options\n    });\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractDeploy(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n    return transaction;\n  }\n}\nexport async function makeUnsignedContractDeploy(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n    clarityVersion: ClarityVersion.Clarity2\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createSmartContractPayload(options.contractName, options.codeBody, options.clarityVersion);\n  let authorization = null;\n  let spendingCondition = null;\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = options.network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function estimateContractFunctionCall(transaction, network) {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(`Contract call fee estimation only possible with ${PayloadType[PayloadType.ContractCall]} transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`);\n  }\n  const requestHeaders = {\n    Accept: 'application/text'\n  };\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders\n  };\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\nexport async function makeUnsignedContractCall(txOptions) {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false\n  };\n  const options = Object.assign(defaultOptions, txOptions);\n  const payload = createContractCallPayload(options.contractAddress, options.contractName, options.functionName, options.functionArgs);\n  if (options?.validateWithAbi) {\n    let abi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n    validateContractCall(payload, abi);\n  }\n  let spendingCondition = null;\n  let authorization = null;\n  if ('publicKey' in options) {\n    spendingCondition = createSingleSigSpendingCondition(AddressHashMode.SerializeP2PKH, options.publicKey, options.nonce, options.fee);\n  } else {\n    spendingCondition = createMultiSigSpendingCondition(AddressHashMode.SerializeP2SH, options.numSignatures, options.publicKeys, options.nonce, options.fee);\n  }\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const postConditions = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(network.version, authorization, payload, lpPostConditions, options.postConditionMode, options.anchorMode, network.chainId);\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n  return transaction;\n}\nexport async function makeContractCall(txOptions) {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({\n      publicKey,\n      ...options\n    });\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n    return transaction;\n  }\n}\nexport function makeStandardSTXPostCondition(address, conditionCode, amount) {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\nexport function makeContractSTXPostCondition(address, contractName, conditionCode, amount) {\n  return createSTXPostCondition(createContractPrincipal(address, contractName), conditionCode, amount);\n}\nexport function makeStandardFungiblePostCondition(address, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createStandardPrincipal(address), conditionCode, amount, assetInfo);\n}\nexport function makeContractFungiblePostCondition(address, contractName, conditionCode, amount, assetInfo) {\n  return createFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, amount, assetInfo);\n}\nexport function makeStandardNonFungiblePostCondition(address, conditionCode, assetInfo, assetId) {\n  return createNonFungiblePostCondition(createStandardPrincipal(address), conditionCode, assetInfo, assetId);\n}\nexport function makeContractNonFungiblePostCondition(address, contractName, conditionCode, assetInfo, assetId) {\n  return createNonFungiblePostCondition(createContractPrincipal(address, contractName), conditionCode, assetInfo, assetId);\n}\nexport async function callReadOnlyFunction(readOnlyFunctionOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n  const {\n    contractName,\n    contractAddress,\n    functionName,\n    functionArgs,\n    senderAddress\n  } = options;\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n  const args = functionArgs.map(arg => cvToHex(arg));\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args\n  });\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\nexport async function getContractMapEntry(getContractMapEntryOptions) {\n  const defaultOptions = {\n    network: new StacksMainnet()\n  };\n  const {\n    contractAddress,\n    contractName,\n    mapName,\n    mapKey,\n    network\n  } = Object.assign(defaultOptions, getContractMapEntryOptions);\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\n  const serializedKeyBytes = serializeCV(mapKey);\n  const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\n  const fetchOptions = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json'\n    },\n    body: JSON.stringify(serializedKeyHex)\n  };\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(`Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`);\n  }\n  const responseBody = await response.text();\n  const responseJson = JSON.parse(responseBody);\n  if (!responseJson.data) {\n    throw new Error(`Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: \"${responseBody}\"`);\n  }\n  let deserializedCv;\n  try {\n    deserializedCv = deserializeCV(responseJson.data);\n  } catch (error) {\n    throw new Error(`Error deserializing Clarity value \"${responseJson.data}\": ${error}`);\n  }\n  return deserializedCv;\n}\nexport async function sponsorTransaction(sponsorOptions) {\n  const defaultOptions = {\n    fee: 0,\n    sponsorNonce: 0,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH,\n    network: sponsorOptions.transaction.version === TransactionVersion.Mainnet ? new StacksMainnet() : new StacksTestnet()\n  };\n  const options = Object.assign(defaultOptions, sponsorOptions);\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.VersionedSmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1].fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(`Sponsored transactions not supported for transaction type ${PayloadType[options.transaction.payload.payloadType]}`);\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion = network.version === TransactionVersion.Mainnet ? AddressVersion.MainnetSingleSig : AddressVersion.TestnetSingleSig;\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(options.sponsorAddressHashmode, publicKeyToString(sponsorPubKey), options.sponsorNonce, options.fee);\n  options.transaction.setSponsor(sponsorSpendingCondition);\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(options.transaction, sponsorSpendingCondition);\n  signer.signSponsor(privKey);\n  return signer.transaction;\n}\nexport function estimateTransactionByteLength(transaction) {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition = transaction.auth.spendingCondition;\n    const existingSignatures = multiSigSpendingCondition.fields.filter(field => field.contents.type === StacksMessageType.MessageSignature).length;\n    const totalSignatureLength = (multiSigSpendingCondition.signaturesRequired - existingSignatures) * (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    return transaction.serialize().byteLength;\n  }\n}\nexport async function estimateTransactionFeeWithFallback(transaction, network) {\n  try {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;\n  } catch (error) {\n    if (error instanceof NoEstimateAvailableError) {\n      return await estimateTransferUnsafe(transaction, network);\n    }\n    throw error;\n  }\n}","map":{"version":3,"names":["bytesToHex","hexToBytes","intToBigInt","StacksNetwork","StacksMainnet","StacksTestnet","createFetchFn","c32address","createMultiSigSpendingCondition","createSingleSigSpendingCondition","createSponsoredAuth","createStandardAuth","deserializeCV","serializeCV","AddressHashMode","AddressVersion","PayloadType","PostConditionMode","TransactionVersion","RECOVERABLE_ECDSA_SIG_LENGTH_BYTES","StacksMessageType","ClarityVersion","validateContractCall","NoEstimateAvailableError","createStacksPrivateKey","getPublicKey","pubKeyfromPrivKey","publicKeyFromBytes","publicKeyToAddress","publicKeyToString","createContractCallPayload","createSmartContractPayload","createTokenTransferPayload","serializePayload","createFungiblePostCondition","createNonFungiblePostCondition","createSTXPostCondition","createContractPrincipal","createStandardPrincipal","TransactionSigner","StacksTransaction","createLPList","cvToHex","omit","parseReadOnlyResponse","validateTxId","getNonce","address","network","derivedNetwork","fromNameOrNetwork","url","getAccountApiUrl","response","fetchFn","ok","msg","text","error","Error","status","statusText","responseText","result","JSON","parse","BigInt","nonce","estimateTransfer","transaction","payload","payloadType","TokenTransfer","estimateTransferUnsafe","requestHeaders","Accept","fetchOptions","method","headers","deriveNetwork","getTransferFeeEstimateApiUrl","feeRateResult","txBytes","serialize","byteLength","feeRate","estimateTransaction","transactionPayload","estimatedLen","options","body","stringify","transaction_payload","estimated_len","getTransactionFeeEstimateApiUrl","json","catch","reason","reason_data","message","data","estimations","broadcastTransaction","attachment","rawTx","getBroadcastApiUrl","broadcastRawTransaction","tx","e","txid","replace","getAbi","contractName","getAbiApiUrl","version","Mainnet","Testnet","makeUnsignedSTXTokenTransfer","txOptions","defaultOptions","fee","memo","sponsored","Object","assign","recipient","amount","authorization","spendingCondition","SerializeP2PKH","publicKey","SerializeP2SH","numSignatures","publicKeys","undefined","anchorMode","chainId","estimateTransactionFeeWithFallback","setFee","addressVersion","MainnetSingleSig","TestnetSingleSig","senderAddress","auth","signer","txNonce","setNonce","makeSTXTokenTransfer","senderKey","privKey","signOrigin","pubKeys","key","signerKeys","pubKey","filter","pk","appendOrigin","estimateContractDeploy","SmartContract","VersionedSmartContract","makeContractDeploy","makeUnsignedContractDeploy","postConditionMode","Deny","clarityVersion","Clarity2","codeBody","postConditions","length","forEach","postCondition","push","lpPostConditions","estimateContractFunctionCall","ContractCall","makeUnsignedContractCall","contractAddress","functionName","functionArgs","validateWithAbi","abi","makeContractCall","makeStandardSTXPostCondition","conditionCode","makeContractSTXPostCondition","makeStandardFungiblePostCondition","assetInfo","makeContractFungiblePostCondition","makeStandardNonFungiblePostCondition","assetId","makeContractNonFungiblePostCondition","callReadOnlyFunction","readOnlyFunctionOptions","getReadOnlyFunctionCallApiUrl","args","map","arg","sender","arguments","then","responseJson","getContractMapEntry","getContractMapEntryOptions","mapName","mapKey","getMapEntryUrl","serializedKeyBytes","serializedKeyHex","responseBody","deserializedCv","sponsorTransaction","sponsorOptions","sponsorNonce","sponsorAddressHashmode","sponsorPubKey","sponsorPrivateKey","txFee","estimateTransactionByteLength","sponsorSpendingCondition","setSponsor","createSponsorSigner","signSponsor","hashMode","multiSigHashModes","SerializeP2WSH","includes","multiSigSpendingCondition","existingSignatures","fields","field","contents","type","MessageSignature","totalSignatureLength","signaturesRequired"],"sources":["/home/ryanosull/clarity/clarity-camp/projects/nft-vids/another-ape-client/node_modules/@stacks/transactions/src/builders.ts"],"sourcesContent":["import { bytesToHex, hexToBytes, IntegerType, intToBigInt } from '@stacks/common';\nimport {\n  StacksNetwork,\n  StacksMainnet,\n  StacksNetworkName,\n  StacksTestnet,\n  FetchFn,\n  createFetchFn,\n} from '@stacks/network';\nimport { c32address } from 'c32check';\nimport {\n  Authorization,\n  createMultiSigSpendingCondition,\n  createSingleSigSpendingCondition,\n  createSponsoredAuth,\n  createStandardAuth,\n  SpendingCondition,\n  MultiSigSpendingCondition,\n} from './authorization';\nimport { ClarityValue, deserializeCV, NoneCV, PrincipalCV, serializeCV } from './clarity';\nimport {\n  AddressHashMode,\n  AddressVersion,\n  AnchorMode,\n  FungibleConditionCode,\n  NonFungibleConditionCode,\n  PayloadType,\n  PostConditionMode,\n  SingleSigHashMode,\n  TransactionVersion,\n  TxRejectedReason,\n  RECOVERABLE_ECDSA_SIG_LENGTH_BYTES,\n  StacksMessageType,\n  ClarityVersion,\n  AnchorModeName,\n} from './constants';\nimport { ClarityAbi, validateContractCall } from './contract-abi';\nimport { NoEstimateAvailableError } from './errors';\nimport {\n  createStacksPrivateKey,\n  getPublicKey,\n  pubKeyfromPrivKey,\n  publicKeyFromBytes,\n  publicKeyToAddress,\n  publicKeyToString,\n} from './keys';\nimport {\n  createContractCallPayload,\n  createSmartContractPayload,\n  createTokenTransferPayload,\n  Payload,\n  serializePayload,\n} from './payload';\nimport {\n  createFungiblePostCondition,\n  createNonFungiblePostCondition,\n  createSTXPostCondition,\n} from './postcondition';\nimport {\n  AssetInfo,\n  createContractPrincipal,\n  createStandardPrincipal,\n  FungiblePostCondition,\n  NonFungiblePostCondition,\n  PostCondition,\n  STXPostCondition,\n} from './postcondition-types';\nimport { TransactionSigner } from './signer';\nimport { StacksTransaction } from './transaction';\nimport { createLPList } from './types';\nimport { cvToHex, omit, parseReadOnlyResponse, validateTxId } from './utils';\n\n/**\n * Lookup the nonce for an address from a core node\n *\n * @param {string} address - the c32check address to look up\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to look up address on\n *\n * @return a promise that resolves to an integer\n */\nexport async function getNonce(\n  address: string,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getAccountApiUrl(address);\n\n  const response = await derivedNetwork.fetchFn(url);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error fetching nonce. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseText = await response.text();\n  const result = JSON.parse(responseText) as { nonce: string };\n  return BigInt(result.nonce);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function instead.\n *\n * Estimate the total transaction fee in microstacks for a token transfer\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateTransfer(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.TokenTransfer) {\n    throw new Error(\n      `Transaction fee estimation only possible with ${\n        PayloadType[PayloadType.TokenTransfer]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  return estimateTransferUnsafe(transaction, network);\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function instead.\n * @internal\n */\nexport async function estimateTransferUnsafe(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    let msg = '';\n    try {\n      msg = await response.text();\n    } catch (error) {}\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = BigInt(transaction.serialize().byteLength);\n  const feeRate = BigInt(feeRateResult);\n  return feeRate * txBytes;\n}\n\ninterface FeeEstimation {\n  fee: number;\n  fee_rate: number;\n}\ninterface FeeEstimateResponse {\n  cost_scalar_change_by_byte: bigint;\n  estimated_cost: {\n    read_count: bigint;\n    read_length: bigint;\n    runtime: bigint;\n    write_count: bigint;\n    write_length: bigint;\n  };\n  estimated_cost_scalar: bigint;\n  estimations: [FeeEstimation, FeeEstimation, FeeEstimation];\n}\n\n/**\n * Estimate the total transaction fee in microstacks for a Stacks transaction\n *\n * @param {StacksTransaction} transaction - the transaction to estimate fees for\n * @param {number} estimatedLen - is an optional argument that provides the endpoint with an\n * estimation of the final length (in bytes) of the transaction, including any post-conditions\n * and signatures\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction fees for\n *\n * @return a promise that resolves to FeeEstimate\n */\nexport async function estimateTransaction(\n  transactionPayload: Payload,\n  estimatedLen?: number,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<[FeeEstimation, FeeEstimation, FeeEstimation]> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      transaction_payload: bytesToHex(serializePayload(transactionPayload)),\n      ...(estimatedLen ? { estimated_len: estimatedLen } : {}),\n    }),\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? new StacksMainnet());\n  const url = derivedNetwork.getTransactionFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, options);\n\n  if (!response.ok) {\n    const body = await response.json().catch(() => ({}));\n\n    if (body?.reason === 'NoEstimateAvailable') {\n      throw new NoEstimateAvailableError(body?.reason_data?.message ?? '');\n    }\n\n    throw new Error(\n      `Error estimating transaction fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${body}\"`\n    );\n  }\n\n  const data: FeeEstimateResponse = await response.json();\n  return data.estimations;\n}\n\nexport type SerializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Serialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type DeserializationRejection = {\n  error: string;\n  reason: TxRejectedReason.Deserialization;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type SignatureValidationRejection = {\n  error: string;\n  reason: TxRejectedReason.SignatureValidation;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type BadNonceRejection = {\n  error: string;\n  reason: TxRejectedReason.BadNonce;\n  reason_data: {\n    expected: number;\n    actual: number;\n    is_origin: boolean;\n    principal: boolean;\n  };\n  txid: string;\n};\n\nexport type FeeTooLowRejection = {\n  error: string;\n  reason: TxRejectedReason.FeeTooLow;\n  reason_data: {\n    expected: number;\n    actual: number;\n  };\n  txid: string;\n};\n\nexport type NotEnoughFundsRejection = {\n  error: string;\n  reason: TxRejectedReason.NotEnoughFunds;\n  reason_data: {\n    expected: string;\n    actual: string;\n  };\n  txid: string;\n};\n\nexport type NoSuchContractRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchContract;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoSuchPublicFunctionRejection = {\n  error: string;\n  reason: TxRejectedReason.NoSuchPublicFunction;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadFunctionArgumentRejection = {\n  error: string;\n  reason: TxRejectedReason.BadFunctionArgument;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ContractAlreadyExistsRejection = {\n  error: string;\n  reason: TxRejectedReason.ContractAlreadyExists;\n  reason_data: {\n    contract_identifier: string;\n  };\n  txid: string;\n};\n\nexport type PoisonMicroblocksDoNotConflictRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblocksDoNotConflict;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockHasUnknownPubKeyHashRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockHasUnknownPubKeyHash;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type PoisonMicroblockIsInvalidRejection = {\n  error: string;\n  reason: TxRejectedReason.PoisonMicroblockIsInvalid;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type BadAddressVersionByteRejection = {\n  error: string;\n  reason: TxRejectedReason.BadAddressVersionByte;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type NoCoinbaseViaMempoolRejection = {\n  error: string;\n  reason: TxRejectedReason.NoCoinbaseViaMempool;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureNoSuchChainTipRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureNoSuchChainTip;\n  reason_data?: undefined;\n  txid: string;\n};\n\nexport type ServerFailureDatabaseRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureDatabase;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type ServerFailureOtherRejection = {\n  error: string;\n  reason: TxRejectedReason.ServerFailureOther;\n  reason_data: {\n    message: string;\n  };\n  txid: string;\n};\n\nexport type TxBroadcastResultOk = {\n  txid: string;\n  error?: undefined;\n  reason?: undefined;\n  reason_data?: undefined;\n};\n\nexport type TxBroadcastResultRejected =\n  | SerializationRejection\n  | DeserializationRejection\n  | SignatureValidationRejection\n  | BadNonceRejection\n  | FeeTooLowRejection\n  | NotEnoughFundsRejection\n  | NoSuchContractRejection\n  | NoSuchPublicFunctionRejection\n  | BadFunctionArgumentRejection\n  | ContractAlreadyExistsRejection\n  | PoisonMicroblocksDoNotConflictRejection\n  | PoisonMicroblockHasUnknownPubKeyHashRejection\n  | PoisonMicroblockIsInvalidRejection\n  | BadAddressVersionByteRejection\n  | NoCoinbaseViaMempoolRejection\n  | ServerFailureNoSuchChainTipRejection\n  | ServerFailureDatabaseRejection\n  | ServerFailureOtherRejection;\n\nexport type TxBroadcastResult = TxBroadcastResultOk | TxBroadcastResultRejected;\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to broadcast\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastTransaction(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork,\n  attachment?: Uint8Array\n): Promise<TxBroadcastResult> {\n  const rawTx = transaction.serialize();\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getBroadcastApiUrl();\n\n  return broadcastRawTransaction(rawTx, url, attachment, derivedNetwork.fetchFn);\n}\n\n/**\n * Broadcast the signed transaction to a core node\n *\n * @param {Uint8Array} rawTx - the raw serialized transaction bytes to broadcast\n * @param {string} url - the broadcast endpoint URL\n *\n * @returns {Promise} that resolves to a response if the operation succeeds\n */\nexport async function broadcastRawTransaction(\n  rawTx: Uint8Array,\n  url: string,\n  attachment?: Uint8Array,\n  fetchFn: FetchFn = createFetchFn()\n): Promise<TxBroadcastResult> {\n  const options = {\n    method: 'POST',\n    headers: { 'Content-Type': attachment ? 'application/json' : 'application/octet-stream' },\n    body: attachment\n      ? JSON.stringify({\n          tx: bytesToHex(rawTx),\n          attachment: bytesToHex(attachment),\n        })\n      : rawTx,\n  };\n\n  const response = await fetchFn(url, options);\n  if (!response.ok) {\n    try {\n      return (await response.json()) as TxBroadcastResult;\n    } catch (e) {\n      throw Error(`Failed to broadcast transaction: ${(e as Error).message}`);\n    }\n  }\n\n  const text = await response.text();\n  // Replace extra quotes around txid string\n  const txid = text.replace(/[\"]+/g, '');\n  if (!validateTxId(txid)) throw new Error(text);\n  return { txid } as TxBroadcastResult;\n}\n\n/**\n * Fetch a contract's ABI\n *\n * @param {string} address - the contracts address\n * @param {string} contractName - the contracts name\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to broadcast transaction to\n *\n * @returns {Promise} that resolves to a ClarityAbi if the operation succeeds\n */\nexport async function getAbi(\n  address: string,\n  contractName: string,\n  network: StacksNetworkName | StacksNetwork\n): Promise<ClarityAbi> {\n  const options = {\n    method: 'GET',\n  };\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getAbiApiUrl(address, contractName);\n\n  const response = await derivedNetwork.fetchFn(url, options);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching contract ABI for contract \"${contractName}\" at address ${address}. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return JSON.parse(await response.text()) as ClarityAbi;\n}\n\nfunction deriveNetwork(transaction: StacksTransaction) {\n  switch (transaction.version) {\n    case TransactionVersion.Mainnet:\n      return new StacksMainnet();\n    case TransactionVersion.Testnet:\n      return new StacksTestnet();\n  }\n}\n\nexport interface MultiSigOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys?: string[];\n}\n\n/**\n * STX token transfer transaction options\n */\nexport interface TokenTransferOptions {\n  /** the address of the recipient of the token transfer */\n  recipient: string | PrincipalCV;\n  /** the amount to be transfered in microstacks */\n  amount: IntegerType;\n  /** the transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** an arbitrary string to include in the transaction, must be less than 34 bytes */\n  memo?: string;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedTokenTransferOptions extends TokenTransferOptions {\n  publicKey: string;\n}\n\nexport interface SignedTokenTransferOptions extends TokenTransferOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigTokenTransferOptions extends TokenTransferOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * Generates an unsigned Stacks token transfer transaction\n *\n * Returns a Stacks token transfer transaction.\n *\n * @param {UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedSTXTokenTransfer(\n  txOptions: UnsignedTokenTransferOptions | UnsignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    memo: '',\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createTokenTransferPayload(options.recipient, options.amount, options.memo);\n\n  let authorization: Authorization | null = null;\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    undefined, // no post conditions on STX transfers (see SIP-005)\n    undefined, // no post conditions on STX transfers (see SIP-005)\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a signed Stacks token transfer transaction\n *\n * Returns a signed Stacks token transfer transaction.\n *\n * @param {SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions} txOptions - an options object for the token transfer\n *\n * @return {StacksTransaction}\n */\nexport async function makeSTXTokenTransfer(\n  txOptions: SignedTokenTransferOptions | SignedMultiSigTokenTransferOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // txOptions is SignedTokenTransferOptions\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedSTXTokenTransfer({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // txOptions is SignedMultiSigTokenTransferOptions\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedSTXTokenTransfer(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Contract deploy transaction options\n */\nexport interface BaseContractDeployOptions {\n  clarityVersion?: ClarityVersion;\n  contractName: string;\n  /** the Clarity code to be deployed */\n  codeBody: string;\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the network that the transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractDeployOptions extends BaseContractDeployOptions {\n  /** a hex string of the public key of the transaction sender */\n  publicKey: string;\n}\n\nexport interface SignedContractDeployOptions extends BaseContractDeployOptions {\n  senderKey: string;\n}\n\n/** @deprecated Use {@link SignedContractDeployOptions} or {@link UnsignedContractDeployOptions} instead. */\nexport interface ContractDeployOptions extends SignedContractDeployOptions {}\n\nexport interface UnsignedMultiSigContractDeployOptions extends BaseContractDeployOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractDeployOptions extends BaseContractDeployOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract deploy\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractDeploy(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (\n    transaction.payload.payloadType !== PayloadType.SmartContract &&\n    transaction.payload.payloadType !== PayloadType.VersionedSmartContract\n  ) {\n    throw new Error(\n      `Contract deploy fee estimation only possible with ${\n        PayloadType[PayloadType.SmartContract]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract deploy fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract deploy fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates a Clarity smart contract deploy transaction\n *\n * @param {SignedContractDeployOptions | SignedMultiSigContractDeployOptions} txOptions - an options object for the contract deploy\n *\n * Returns a signed Stacks smart contract deploy transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractDeploy(\n  txOptions: SignedContractDeployOptions | SignedMultiSigContractDeployOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    // txOptions is SignedContractDeployOptions\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractDeploy({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    // txOptions is SignedMultiSigContractDeployOptions\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractDeploy(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n\n    return transaction;\n  }\n}\n\nexport async function makeUnsignedContractDeploy(\n  txOptions: UnsignedContractDeployOptions | UnsignedMultiSigContractDeployOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n    clarityVersion: ClarityVersion.Clarity2,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createSmartContractPayload(\n    options.contractName,\n    options.codeBody,\n    options.clarityVersion\n  );\n\n  let authorization: Authorization | null = null;\n\n  let spendingCondition: SpendingCondition | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n  const lpPostConditions = createLPList(postConditions);\n\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      options.network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, options.network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Contract function call transaction options\n */\nexport interface ContractCallOptions {\n  /** the Stacks address of the contract */\n  contractAddress: string;\n  contractName: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** transaction fee in microstacks */\n  fee?: IntegerType;\n  feeEstimateApiUrl?: string;\n  /** the transaction nonce, which must be increased monotonically with each new transaction */\n  nonce?: IntegerType;\n  /** the Stacks blockchain network that will ultimately be used to broadcast this transaction */\n  network?: StacksNetworkName | StacksNetwork;\n  /** the transaction anchorMode, which specifies whether it should be\n   * included in an anchor block or a microblock */\n  anchorMode: AnchorModeName | AnchorMode;\n  /** the post condition mode, specifying whether or not post-conditions must fully cover all\n   * transfered assets */\n  postConditionMode?: PostConditionMode;\n  /** a list of post conditions to add to the transaction */\n  postConditions?: PostCondition[];\n  /** set to true to validate that the supplied function args match those specified in\n   * the published contract */\n  validateWithAbi?: boolean | ClarityAbi;\n  /** set to true if another account is sponsoring the transaction (covering the transaction fee) */\n  sponsored?: boolean;\n}\n\nexport interface UnsignedContractCallOptions extends ContractCallOptions {\n  publicKey: string;\n}\n\nexport interface SignedContractCallOptions extends ContractCallOptions {\n  senderKey: string;\n}\n\nexport interface UnsignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n}\n\nexport interface SignedMultiSigContractCallOptions extends ContractCallOptions {\n  numSignatures: number;\n  publicKeys: string[];\n  signerKeys: string[];\n}\n\n/**\n * @deprecated Use the new {@link estimateTransaction} function insterad.\n *\n * Estimate the total transaction fee in microstacks for a contract function call\n *\n * @param {StacksTransaction} transaction - the token transfer transaction to estimate fees for\n * @param {StacksNetworkName | StacksNetwork} network - the Stacks network to estimate transaction for\n *\n * @return a promise that resolves to number of microstacks per byte\n */\nexport async function estimateContractFunctionCall(\n  transaction: StacksTransaction,\n  network?: StacksNetworkName | StacksNetwork\n): Promise<bigint> {\n  if (transaction.payload.payloadType !== PayloadType.ContractCall) {\n    throw new Error(\n      `Contract call fee estimation only possible with ${\n        PayloadType[PayloadType.ContractCall]\n      } transactions. Invoked with: ${PayloadType[transaction.payload.payloadType]}`\n    );\n  }\n\n  const requestHeaders = {\n    Accept: 'application/text',\n  };\n\n  const fetchOptions = {\n    method: 'GET',\n    headers: requestHeaders,\n  };\n\n  // Place holder estimate until contract call fee estimation is fully implemented on Stacks\n  // blockchain core\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network ?? deriveNetwork(transaction));\n  const url = derivedNetwork.getTransferFeeEstimateApiUrl();\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error estimating contract call fee. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const feeRateResult = await response.text();\n  const txBytes = intToBigInt(transaction.serialize().byteLength, false);\n  const feeRate = intToBigInt(feeRateResult, false);\n  return feeRate * txBytes;\n}\n\n/**\n * Generates an unsigned Clarity smart contract function call transaction\n *\n * @param {UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions} txOptions - an options object for the contract call\n *\n * @returns {Promise<StacksTransaction>}\n */\nexport async function makeUnsignedContractCall(\n  txOptions: UnsignedContractCallOptions | UnsignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: BigInt(0),\n    nonce: BigInt(0),\n    network: new StacksMainnet(),\n    postConditionMode: PostConditionMode.Deny,\n    sponsored: false,\n  };\n\n  const options = Object.assign(defaultOptions, txOptions);\n\n  const payload = createContractCallPayload(\n    options.contractAddress,\n    options.contractName,\n    options.functionName,\n    options.functionArgs\n  );\n\n  if (options?.validateWithAbi) {\n    let abi: ClarityAbi;\n    if (typeof options.validateWithAbi === 'boolean') {\n      if (options?.network) {\n        abi = await getAbi(options.contractAddress, options.contractName, options.network);\n      } else {\n        throw new Error('Network option must be provided in order to validate with ABI');\n      }\n    } else {\n      abi = options.validateWithAbi;\n    }\n\n    validateContractCall(payload, abi);\n  }\n\n  let spendingCondition: SpendingCondition | null = null;\n  let authorization: Authorization | null = null;\n\n  if ('publicKey' in options) {\n    // single-sig\n    spendingCondition = createSingleSigSpendingCondition(\n      AddressHashMode.SerializeP2PKH,\n      options.publicKey,\n      options.nonce,\n      options.fee\n    );\n  } else {\n    // multi-sig\n    spendingCondition = createMultiSigSpendingCondition(\n      AddressHashMode.SerializeP2SH,\n      options.numSignatures,\n      options.publicKeys,\n      options.nonce,\n      options.fee\n    );\n  }\n\n  if (options.sponsored) {\n    authorization = createSponsoredAuth(spendingCondition);\n  } else {\n    authorization = createStandardAuth(spendingCondition);\n  }\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n\n  const postConditions: PostCondition[] = [];\n  if (options.postConditions && options.postConditions.length > 0) {\n    options.postConditions.forEach(postCondition => {\n      postConditions.push(postCondition);\n    });\n  }\n\n  const lpPostConditions = createLPList(postConditions);\n  const transaction = new StacksTransaction(\n    network.version,\n    authorization,\n    payload,\n    lpPostConditions,\n    options.postConditionMode,\n    options.anchorMode,\n    network.chainId\n  );\n\n  if (txOptions.fee === undefined || txOptions.fee === null) {\n    const fee = await estimateTransactionFeeWithFallback(transaction, network);\n    transaction.setFee(fee);\n  }\n\n  if (txOptions.nonce === undefined || txOptions.nonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n    const senderAddress = c32address(addressVersion, transaction.auth.spendingCondition!.signer);\n    const txNonce = await getNonce(senderAddress, network);\n    transaction.setNonce(txNonce);\n  }\n\n  return transaction;\n}\n\n/**\n * Generates a Clarity smart contract function call transaction\n *\n * @param {SignedContractCallOptions | SignedMultiSigContractCallOptions} txOptions - an options object for the contract function call\n *\n * Returns a signed Stacks smart contract function call transaction.\n *\n * @return {StacksTransaction}\n */\nexport async function makeContractCall(\n  txOptions: SignedContractCallOptions | SignedMultiSigContractCallOptions\n): Promise<StacksTransaction> {\n  if ('senderKey' in txOptions) {\n    const publicKey = publicKeyToString(getPublicKey(createStacksPrivateKey(txOptions.senderKey)));\n    const options = omit(txOptions, 'senderKey');\n    const transaction = await makeUnsignedContractCall({ publicKey, ...options });\n\n    const privKey = createStacksPrivateKey(txOptions.senderKey);\n    const signer = new TransactionSigner(transaction);\n    signer.signOrigin(privKey);\n\n    return transaction;\n  } else {\n    const options = omit(txOptions, 'signerKeys');\n    const transaction = await makeUnsignedContractCall(options);\n\n    const signer = new TransactionSigner(transaction);\n    let pubKeys = txOptions.publicKeys;\n    for (const key of txOptions.signerKeys) {\n      const pubKey = pubKeyfromPrivKey(key);\n      pubKeys = pubKeys.filter(pk => pk !== bytesToHex(pubKey.data));\n      signer.signOrigin(createStacksPrivateKey(key));\n    }\n\n    for (const key of pubKeys) {\n      signer.appendOrigin(publicKeyFromBytes(hexToBytes(key)));\n    }\n\n    return transaction;\n  }\n}\n\n/**\n * Generates a STX post condition with a standard principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens (denoted in micro-STX)\n */\nexport function makeStandardSTXPostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(createStandardPrincipal(address), conditionCode, amount);\n}\n\n/**\n * Generates a STX post condition with a contract principal\n *\n * Returns a STX post condition object\n *\n * @param address - the c32check address of the contract\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of STX tokens (denoted in micro-STX)\n *\n * @return {STXPostCondition}\n */\nexport function makeContractSTXPostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType\n): STXPostCondition {\n  return createSTXPostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount\n  );\n}\n\n/**\n * Generates a fungible token post condition with a standard principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens (in their respective base unit)\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeStandardFungiblePostCondition(\n  address: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a fungible token post condition with a contract principal\n *\n * Returns a fungible token post condition object\n *\n * @param address - the c32check address\n * @param contractName - the name of the contract\n * @param conditionCode - the condition code\n * @param amount - the amount of fungible tokens (in their respective base unit)\n * @param assetInfo - asset info describing the fungible token\n */\nexport function makeContractFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: FungibleConditionCode,\n  amount: IntegerType,\n  assetInfo: string | AssetInfo\n): FungiblePostCondition {\n  return createFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    amount,\n    assetInfo\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a standard principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param {String} address - the c32check address\n * @param {FungibleConditionCode} conditionCode - the condition code\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeStandardNonFungiblePostCondition(\n  address: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetId: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createStandardPrincipal(address),\n    conditionCode,\n    assetInfo,\n    assetId\n  );\n}\n\n/**\n * Generates a non-fungible token post condition with a contract principal\n *\n * Returns a non-fungible token post condition object\n *\n * @param {String} address - the c32check address\n * @param {String} contractName - the name of the contract\n * @param {FungibleConditionCode} conditionCode - the condition code\n * @param {AssetInfo} assetInfo - asset info describing the non-fungible token\n * @param {ClarityValue} assetId - asset identifier of the nft instance (typically a uint/buffer/string)\n *\n * @return {NonFungiblePostCondition}\n */\nexport function makeContractNonFungiblePostCondition(\n  address: string,\n  contractName: string,\n  conditionCode: NonFungibleConditionCode,\n  assetInfo: string | AssetInfo,\n  assetId: ClarityValue\n): NonFungiblePostCondition {\n  return createNonFungiblePostCondition(\n    createContractPrincipal(address, contractName),\n    conditionCode,\n    assetInfo,\n    assetId\n  );\n}\n\n/**\n * Read only function options\n *\n * @param {String} contractAddress - the c32check address of the contract\n * @param {String} contractName - the contract name\n * @param {String} functionName - name of the function to be called\n * @param {[ClarityValue]} functionArgs - an array of Clarity values as arguments to the function call\n * @param {StacksNetwork} network - the Stacks blockchain network this transaction is destined for\n * @param {String} senderAddress - the c32check address of the sender\n */\n\nexport interface ReadOnlyFunctionOptions {\n  contractName: string;\n  contractAddress: string;\n  functionName: string;\n  functionArgs: ClarityValue[];\n  /** the network that the contract which contains the function is deployed to */\n  network?: StacksNetworkName | StacksNetwork;\n  /** address of the sender */\n  senderAddress: string;\n}\n\n/**\n * Calls a function as read-only from a contract interface\n * It is not necessary that the function is defined as read-only in the contract\n *\n * @param {ReadOnlyFunctionOptions} readOnlyFunctionOptions - the options object\n *\n * Returns an object with a status bool (okay) and a result string that is a serialized clarity value in hex format.\n *\n * @return {ClarityValue}\n */\nexport async function callReadOnlyFunction(\n  readOnlyFunctionOptions: ReadOnlyFunctionOptions\n): Promise<ClarityValue> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n\n  const options = Object.assign(defaultOptions, readOnlyFunctionOptions);\n\n  const { contractName, contractAddress, functionName, functionArgs, senderAddress } = options;\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const url = network.getReadOnlyFunctionCallApiUrl(contractAddress, contractName, functionName);\n\n  const args = functionArgs.map(arg => cvToHex(arg));\n\n  const body = JSON.stringify({\n    sender: senderAddress,\n    arguments: args,\n  });\n\n  const response = await network.fetchFn(url, {\n    method: 'POST',\n    body,\n    headers: {\n      'Content-Type': 'application/json',\n    },\n  });\n\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error calling read-only function. Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n\n  return response.json().then(responseJson => parseReadOnlyResponse(responseJson));\n}\n\nexport interface GetContractMapEntryOptions {\n  /** the contracts address */\n  contractAddress: string;\n  /** the contracts name */\n  contractName: string;\n  /** the map name */\n  mapName: string;\n  /** key to lookup in the map */\n  mapKey: ClarityValue;\n  /** the network that has the contract */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Fetch data from a contract data map.\n * @param getContractMapEntryOptions - the options object\n * @returns\n * Promise that resolves to a ClarityValue if the operation succeeds.\n * Resolves to NoneCV if the map does not contain the given key, if the map does not exist, or if the contract prinicipal does not exist\n */\nexport async function getContractMapEntry<T extends ClarityValue = ClarityValue>(\n  getContractMapEntryOptions: GetContractMapEntryOptions\n): Promise<T | NoneCV> {\n  const defaultOptions = {\n    network: new StacksMainnet(),\n  };\n  const { contractAddress, contractName, mapName, mapKey, network } = Object.assign(\n    defaultOptions,\n    getContractMapEntryOptions\n  );\n\n  const derivedNetwork = StacksNetwork.fromNameOrNetwork(network);\n  const url = derivedNetwork.getMapEntryUrl(contractAddress, contractName, mapName);\n\n  const serializedKeyBytes = serializeCV(mapKey);\n  const serializedKeyHex = '0x' + bytesToHex(serializedKeyBytes);\n\n  const fetchOptions: RequestInit = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n    },\n    body: JSON.stringify(serializedKeyHex), // endpoint expects a JSON string atom (quote wrapped string)\n  };\n\n  const response = await derivedNetwork.fetchFn(url, fetchOptions);\n  if (!response.ok) {\n    const msg = await response.text().catch(() => '');\n    throw new Error(\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the message: \"${msg}\"`\n    );\n  }\n  const responseBody = await response.text();\n  const responseJson: { data?: string } = JSON.parse(responseBody);\n  if (!responseJson.data) {\n    throw new Error(\n      `Error fetching map entry for map \"${mapName}\" in contract \"${contractName}\" at address ${contractAddress}, using map key \"${serializedKeyHex}\". Response ${response.status}: ${response.statusText}. Attempted to fetch ${url} and failed with the response: \"${responseBody}\"`\n    );\n  }\n  let deserializedCv: T;\n  try {\n    deserializedCv = deserializeCV<T>(responseJson.data);\n  } catch (error) {\n    throw new Error(`Error deserializing Clarity value \"${responseJson.data}\": ${error}`);\n  }\n  return deserializedCv;\n}\n\n/**\n * Sponsored transaction options\n */\nexport interface SponsorOptionsOpts {\n  /** the origin-signed transaction */\n  transaction: StacksTransaction;\n  /** the sponsor's private key */\n  sponsorPrivateKey: string;\n  /** the transaction fee amount to sponsor */\n  fee?: IntegerType;\n  /** the nonce of the sponsor account */\n  sponsorNonce?: IntegerType;\n  /** the hashmode of the sponsor's address */\n  sponsorAddressHashmode?: AddressHashMode;\n  /** the Stacks blockchain network that this transaction will ultimately be broadcast to */\n  network?: StacksNetworkName | StacksNetwork;\n}\n\n/**\n * Constructs and signs a sponsored transaction as the sponsor\n *\n * @param {SponsorOptionsOpts} sponsorOptions - the sponsor options object\n *\n * Returns a signed sponsored transaction.\n *\n * @return {ClarityValue}\n */\nexport async function sponsorTransaction(\n  sponsorOptions: SponsorOptionsOpts\n): Promise<StacksTransaction> {\n  const defaultOptions = {\n    fee: 0 as IntegerType,\n    sponsorNonce: 0 as IntegerType,\n    sponsorAddressHashmode: AddressHashMode.SerializeP2PKH as SingleSigHashMode,\n    network:\n      sponsorOptions.transaction.version === TransactionVersion.Mainnet\n        ? new StacksMainnet()\n        : new StacksTestnet(),\n  };\n\n  const options = Object.assign(defaultOptions, sponsorOptions);\n\n  const network = StacksNetwork.fromNameOrNetwork(options.network);\n  const sponsorPubKey = pubKeyfromPrivKey(options.sponsorPrivateKey);\n\n  if (sponsorOptions.fee === undefined || sponsorOptions.fee === null) {\n    let txFee = 0;\n    switch (options.transaction.payload.payloadType) {\n      case PayloadType.TokenTransfer:\n      case PayloadType.SmartContract:\n      case PayloadType.VersionedSmartContract:\n      case PayloadType.ContractCall:\n        const estimatedLen = estimateTransactionByteLength(options.transaction);\n        try {\n          txFee = (await estimateTransaction(options.transaction.payload, estimatedLen, network))[1]\n            .fee;\n        } catch (e) {\n          throw e;\n        }\n        break;\n      default:\n        throw new Error(\n          `Sponsored transactions not supported for transaction type ${\n            PayloadType[options.transaction.payload.payloadType]\n          }`\n        );\n    }\n    options.transaction.setFee(txFee);\n    options.fee = txFee;\n  }\n\n  if (sponsorOptions.sponsorNonce === undefined || sponsorOptions.sponsorNonce === null) {\n    const addressVersion =\n      network.version === TransactionVersion.Mainnet\n        ? AddressVersion.MainnetSingleSig\n        : AddressVersion.TestnetSingleSig;\n\n    const senderAddress = publicKeyToAddress(addressVersion, sponsorPubKey);\n    const sponsorNonce = await getNonce(senderAddress, network);\n    options.sponsorNonce = sponsorNonce;\n  }\n\n  const sponsorSpendingCondition = createSingleSigSpendingCondition(\n    options.sponsorAddressHashmode,\n    publicKeyToString(sponsorPubKey),\n    options.sponsorNonce,\n    options.fee\n  );\n\n  options.transaction.setSponsor(sponsorSpendingCondition);\n\n  const privKey = createStacksPrivateKey(options.sponsorPrivateKey);\n  const signer = TransactionSigner.createSponsorSigner(\n    options.transaction,\n    sponsorSpendingCondition\n  );\n  signer.signSponsor(privKey);\n\n  return signer.transaction;\n}\n\n/**\n * Estimates transaction byte length\n * Context:\n * 1) Multi-sig transaction byte length increases by adding signatures\n *    which causes the incorrect fee estimation because the fee value is set while creating unsigned transaction\n * 2) Single-sig transaction byte length remain same due to empty message signature which allocates the space for signature\n * @param {transaction} - StacksTransaction object to be estimated\n * @return {number} Estimated transaction byte length\n */\nexport function estimateTransactionByteLength(transaction: StacksTransaction): number {\n  const hashMode = transaction.auth.spendingCondition.hashMode;\n  // List of Multi-sig transaction hash modes\n  const multiSigHashModes = [AddressHashMode.SerializeP2SH, AddressHashMode.SerializeP2WSH];\n\n  // Check if its a Multi-sig transaction\n  if (multiSigHashModes.includes(hashMode)) {\n    const multiSigSpendingCondition: MultiSigSpendingCondition = transaction.auth\n      .spendingCondition as MultiSigSpendingCondition;\n\n    // Find number of existing signatures if the transaction is signed or partially signed\n    const existingSignatures = multiSigSpendingCondition.fields.filter(\n      field => field.contents.type === StacksMessageType.MessageSignature\n    ).length; // existingSignatures will be 0 if its a unsigned transaction\n\n    // Estimate total signature bytes size required for this multi-sig transaction\n    // Formula: totalSignatureLength = (signaturesRequired - existingSignatures) * (SIG_LEN_BYTES + 1 byte of type of signature)\n    const totalSignatureLength =\n      (multiSigSpendingCondition.signaturesRequired - existingSignatures) *\n      (RECOVERABLE_ECDSA_SIG_LENGTH_BYTES + 1);\n\n    return transaction.serialize().byteLength + totalSignatureLength;\n  } else {\n    // Single-sig transaction\n    // Signature space already allocated by empty message signature\n    return transaction.serialize().byteLength;\n  }\n}\n\n/**\n * Estimates the fee using {@link estimateTransfer} as a fallback if\n * {@link estimateTransaction} does not get an estimation due to the\n * {@link NoEstimateAvailableError} error.\n */\nexport async function estimateTransactionFeeWithFallback(\n  transaction: StacksTransaction,\n  network: StacksNetwork\n): Promise<bigint | number> {\n  try {\n    const estimatedLen = estimateTransactionByteLength(transaction);\n    return (await estimateTransaction(transaction.payload, estimatedLen, network))[1].fee;\n  } catch (error) {\n    if (error instanceof NoEstimateAvailableError) {\n      return await estimateTransferUnsafe(transaction, network);\n    }\n    throw error;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}