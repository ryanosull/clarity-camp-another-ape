import { AppConfig, UserSession } from '@stacks/auth';
export * from '@stacks/auth';
import { decodeToken, SECP256K1Client, createUnsecuredToken, TokenSigner } from 'jsontokens';
import { StacksTestnet } from '@stacks/network';
import { ChainID, serializeCV, serializePostCondition, deserializeTransaction } from '@stacks/transactions';
import { defineCustomElements } from '@stacks/connect-ui/loader';

var X=Object.defineProperty,M=Object.defineProperties;var L=Object.getOwnPropertyDescriptors;var T=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,R=Object.prototype.propertyIsEnumerable;var b=(e,t,n)=>t in e?X(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,a=(e,t)=>{for(var n in t||(t={}))D.call(t,n)&&b(e,n,t[n]);if(T)for(var n of T(t))R.call(t,n)&&b(e,n,t[n]);return e},c=(e,t)=>M(e,L(t));var f=(e,t)=>{var n={};for(var r in e)D.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(e!=null&&T)for(var r of T(e))t.indexOf(r)<0&&R.call(e,r)&&(n[r]=e[r]);return n};function d(){return window.StacksProvider||window.BlockstackProvider}function zt(){return !!d()}var Ht="https://app.blockstack.org",B="7.4.0";typeof window!="undefined"&&(window.__CONNECT_VERSION__=B);var z=()=>{let e=navigator.userAgent;return /android/i.test(e)||/iPad|iPhone|iPod/.test(e)?!0:/windows phone/i.test(e)},Qt=()=>!z(),U=e=>{if(!e){let t=new AppConfig(["store_write"],document.location.href);e=new UserSession({appConfig:t});}return e},A=async(e,t=d())=>{if(!t)throw new Error("[Connect] No installed Stacks wallet found");let{redirectTo:n="/",manifestPath:r,onFinish:s,onCancel:o,sendToSignIn:i=!1,userSession:p,appDetails:u}=e,l=U(p);l.isUserSignedIn()&&l.signUserOut();let S=l.generateAndStoreTransitKey(),F=l.makeAuthRequest(S,`${document.location.origin}${n}`,`${document.location.origin}${r}`,l.appConfig.scopes,void 0,void 0,{sendToSignIn:i,appDetails:u,connectVersion:B});try{let P=await t.authenticationRequest(F);await l.handlePendingSignIn(P);let h=decodeToken(P),$=h==null?void 0:h.payload;s==null||s({authResponse:P,authResponsePayload:$,userSession:l});}catch(P){console.error("[Connect] Error during auth request",P),o==null||o();}},Zt=async e=>(e=U(e),e.isUserSignedIn()?e.loadUserData():e.isSignInPending()?e.handlePendingSignIn():null);var Y=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function m(e){if(!(e instanceof Uint8Array))throw new Error("Uint8Array expected");let t="";for(let n of e)t+=Y[n];return t}function I(e){if(typeof e!="string")throw new TypeError(`hexToBytes: expected string, got ${typeof e}`);let t=e.length%2?`0${e}`:e,n=new Uint8Array(t.length/2);for(let r=0;r<n.length;r++){let s=r*2,o=t.slice(s,s+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");n[r]=i;}return n}var G=(r=>(r.ContractCall="contract_call",r.ContractDeploy="smart_contract",r.STXTransfer="token_transfer",r))(G||{}),W=(o=>(o.BUFFER="buffer",o.UINT="uint",o.INT="int",o.PRINCIPAL="principal",o.BOOL="bool",o))(W||{});var x=e=>{let t=e;if(!t){let n=new AppConfig(["store_write"],document.location.href);t=new UserSession({appConfig:n});}return t};function g(e){try{return x(e).loadUserData().appPrivateKey}catch(t){return !1}}var y=e=>{let n=x(e).loadUserData().appPrivateKey,r=SECP256K1Client.derivePublicKey(n);return {privateKey:n,publicKey:r}};function st(e){var p;let{stxAddress:t,userSession:n,network:r}=e;if(t)return t;if(!n||!r)return;let s=(p=n==null?void 0:n.loadUserData().profile)==null?void 0:p.stxAddress,o={[ChainID.Mainnet]:"mainnet",[ChainID.Testnet]:"testnet"};return s==null?void 0:s[o[r.chainId]]}function at(e){let t=e.network||new StacksTestnet,n=x(e.userSession),r=c(a({},e),{network:t,userSession:n});return a({stxAddress:st(r)},r)}function E(e){return e.map(t=>m(serializePostCondition(t)))}async function C(e,t){let{postConditions:n}=e;return n&&typeof n[0]!="string"&&(n=E(n)),new TokenSigner("ES256k",t).signAsync(c(a({},e),{postConditions:n}))}function w(e){let{postConditions:t}=e;return t&&typeof t[0]!="string"&&(t=E(t)),createUnsecuredToken(c(a({},e),{postConditions:t}))}var it=async({token:e,options:t},n)=>{var r,s,o;try{let i=await n.transactionRequest(e),{txRaw:p}=i,u=I(p.replace(/^0x/,"")),l=deserializeTransaction(u);if("sponsored"in t&&t.sponsored){(r=t.onFinish)==null||r.call(t,c(a({},i),{stacksTransaction:l}));return}(s=t.onFinish)==null||s.call(t,c(a({},i),{stacksTransaction:l}));}catch(i){console.error("[Connect] Error during transaction request",i),(o=t.onCancel)==null||o.call(t);}},ct=async e=>{let p=e,{functionArgs:t,appDetails:n,userSession:r}=p,s=f(p,["functionArgs","appDetails","userSession"]),o=t.map(u=>typeof u=="string"?u:m(serializeCV(u)));if(g(r)){let{privateKey:u,publicKey:l}=y(r),S=c(a({},s),{functionArgs:o,txType:"contract_call",publicKey:l});return n&&(S.appDetails=n),C(S,u)}let i=c(a({},s),{functionArgs:o,txType:"contract_call"});return n&&(i.appDetails=n),w(i)},pt=async e=>{let o=e,{appDetails:t,userSession:n}=o,r=f(o,["appDetails","userSession"]);if(g(n)){let{privateKey:i,publicKey:p}=y(n),u=c(a({},r),{publicKey:p,txType:"smart_contract"});return t&&(u.appDetails=t),C(u,i)}let s=c(a({},r),{txType:"smart_contract"});return t&&(s.appDetails=t),w(s)},ut=async e=>{let i=e,{amount:t,appDetails:n,userSession:r}=i,s=f(i,["amount","appDetails","userSession"]);if(g(r)){let{privateKey:p,publicKey:u}=y(r),l=c(a({},s),{amount:t.toString(10),publicKey:u,txType:"token_transfer"});return n&&(l.appDetails=n),C(l,p)}let o=c(a({},s),{amount:t.toString(10),txType:"token_transfer"});return n&&(o.appDetails=n),w(o)};async function k(e,t,n){let r=await t(a(a({},at(e)),e));return it({token:r,options:e},n)}function le(e,t=d()){if(!t)throw new Error("[Connect] No installed Stacks wallet found");return k(e,ct,t)}function de(e,t=d()){if(!t)throw new Error("[Connect] No installed Stacks wallet found");return k(e,pt,t)}function fe(e,t=d()){if(!t)throw new Error("[Connect] No installed Stacks wallet found");return k(e,ut,t)}async function gt(e,t){return new TokenSigner("ES256k",t).signAsync(a({},e))}function yt(e){let t=e.network||new StacksTestnet,n=x(e.userSession),r=c(a({},e),{network:t,userSession:n});return a({},r)}async function xt({token:e,options:t},n){var r,s;if(!n)throw new Error("[Connect] No installed Stacks wallet found");try{let o=await n.psbtRequest(e);(r=t.onFinish)==null||r.call(t,o);}catch(o){console.error("[Connect] Error during psbt request",o),(s=t.onCancel)==null||s.call(t);}}var St=async e=>{let p=e,{allowedSighash:t,hex:n,signAtIndex:r,userSession:s}=p,o=f(p,["allowedSighash","hex","signAtIndex","userSession"]);if(g(s)){let{privateKey:u,publicKey:l}=y(s),S=c(a({},o),{allowedSighash:t,hex:n,signAtIndex:r,publicKey:l});return gt(S,u)}let i=a({},o);return createUnsecuredToken(i)};async function mt(e,t,n){let r=await t(a(a({},yt(e)),e));return xt({token:r,options:e},n)}function he(e,t=d()){return mt(e,St,t)}function Ct(e){var i;let{userSession:t,network:n}=e;if(!t||!n)return;let r=(i=t==null?void 0:t.loadUserData().profile)==null?void 0:i.stxAddress,s={[ChainID.Mainnet]:"mainnet",[ChainID.Testnet]:"testnet"};return r==null?void 0:r[s[n.chainId]]}async function wt(e,t){return new TokenSigner("ES256k",t).signAsync(a({},e))}function O(e){let t=e.network||new StacksTestnet,n=x(e.userSession),r=c(a({},e),{network:t,userSession:n});return a({stxAddress:Ct(r)},r)}async function kt({token:e,options:t},n){var r,s;try{let o=await n.signatureRequest(e);(r=t.onFinish)==null||r.call(t,o);}catch(o){console.error("[Connect] Error during signature request",o),(s=t.onCancel)==null||s.call(t);}}var Ot=async e=>{let s=e,{userSession:t}=s,n=f(s,["userSession"]);if(g(t)){let{privateKey:o,publicKey:i}=y(t),p=c(a({},n),{publicKey:i});return wt(p,o)}let r=a({},n);return createUnsecuredToken(r)};async function bt(e,t,n){let r=await t(a(a({},O(e)),e));return kt({token:r,options:e},n)}function Be(e,t=d()){if(!t)throw new Error("[Connect] No installed Stacks wallet found");return bt(e,Ot,t)}async function Bt(e,t,n){let r=await t(a(a({},O(e)),e));return It({token:r,options:e},n)}function N(e){return c(a({},e),{message:m(serializeCV(e.message)),domain:m(serializeCV(e.domain))})}async function Ut(e,t){return new TokenSigner("ES256k",t).signAsync(N(e))}async function At(e){let r=e,{userSession:t}=r,n=f(r,["userSession"]);if(g(t)){let{privateKey:s,publicKey:o}=y(t),i=c(a({},n),{publicKey:o});return Ut(i,s)}return createUnsecuredToken(N(e))}async function It({token:e,options:t},n){var r,s;try{let o=await n.structuredDataSignatureRequest(e);(r=t.onFinish)==null||r.call(t,o);}catch(o){console.error("[Connect] Error during signature request",o),(s=t.onCancel)==null||s.call(t);}}function Fe(e,t=d()){if(!t)throw new Error("[Connect] No installed Stacks wallet found");return Bt(e,At,t)}async function Kt(e,t){return new TokenSigner("ES256k",t).signAsync(a({},e))}function Nt(e){let t=e.network||new StacksTestnet,n=x(e.userSession),r=c(a({},e),{network:t,userSession:n});return a({},r)}async function Ft({token:e,options:t},n){var r,s;try{let o=await n.profileUpdateRequest(e);(r=t.onFinish)==null||r.call(t,o);}catch(o){console.error("[Connect] Error during signature request",o),(s=t.onCancel)==null||s.call(t);}}var $t=async e=>{let o=e,{userSession:t,profile:n}=o,r=f(o,["userSession","profile"]);if(g(t)){let{privateKey:i,publicKey:p}=y(t),u=c(a({},r),{profile:n,publicKey:p});return Kt(u,i)}let s=a({},r);return createUnsecuredToken(s)};async function Xt(e,t,n){let r=await t(a(a({},Nt(e)),e));return Ft({token:r,options:e},n)}function ze(e,t=d()){if(!t)throw new Error("[Connect] No installed Stacks wallet found");return Xt(e,$t,t)}var Mt=(o=>(o[o.DEFAULT=0]="DEFAULT",o[o.ALL=1]="ALL",o[o.NONE=2]="NONE",o[o.SINGLE=3]="SINGLE",o[o.ANYONECANPAY=128]="ANYONECANPAY",o))(Mt||{});var _t=(e,t=d())=>{if(t){A(e,t);return}if(typeof window!==void 0){defineCustomElements(window);let n=document.createElement("connect-modal");n.authOptions=e,document.body.appendChild(n);let r=s=>{s.key==="Escape"&&(document.removeEventListener("keydown",r),n.remove());};document.addEventListener("keydown",r);}},Ze=e=>_t(e);

export { W as ContractCallArgumentType, Mt as SignatureHash, G as TransactionTypes, A as authenticate, Ht as defaultAuthURL, Nt as getDefaultProfileUpdateRequestOptions, yt as getDefaultPsbtRequestOptions, O as getDefaultSignatureRequestOptions, y as getKeys, U as getOrCreateUserSession, d as getStacksProvider, st as getStxAddress, Zt as getUserData, x as getUserSession, g as hasAppPrivateKey, z as isMobile, zt as isStacksWalletInstalled, ct as makeContractCallToken, pt as makeContractDeployToken, $t as makeProfileUpdateToken, St as makePsbtToken, ut as makeSTXTransferToken, le as openContractCall, de as openContractDeploy, ze as openProfileUpdateRequestPopup, he as openPsbtRequestPopup, fe as openSTXTransfer, Be as openSignatureRequestPopup, Fe as openStructuredDataSignatureRequestPopup, Qt as shouldUsePopup, Ze as showBlockstackConnect, _t as showConnect, Ot as signMessage, At as signStructuredMessage };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map